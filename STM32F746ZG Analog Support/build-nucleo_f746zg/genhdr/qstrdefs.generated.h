// 32   1732 0000 0
// 97 a 941 0001 1
// 101 e 1660 0010 2
// 105 i 1003 0011 3
// 110 n 1111 0100 4
// 111 o 1081 0101 5
// 114 r 1091 0110 6
// 115 s 893 0111 7
// 116 t 1391 1000 8
// 95 _ 457 10010 18
// 99 c 492 10011 19
// 100 d 578 10100 20
// 108 l 590 10101 21
// 109 m 470 10110 22
// 112 p 445 10111 23
// 117 u 588 11000 24
// 98 b 271 110010 50
// 102 f 313 110011 51
// 103 g 268 110100 52
// 121 y 218 110101 53
// 39 \' 120 1101100 108
// 48 0 109 1101101 109
// 69 E 114 1101110 110
// 80 P 178 1101111 111
// 104 h 218 1110000 112
// 118 v 157 1110001 113
// 120 x 112 1110010 114
// 37 % 81 11100110 230
// 46 . 61 11100111 231
// 49 1 90 11101000 232
// 65 A 76 11101001 233
// 67 C 73 11101010 234
// 68 D 91 11101011 235
// 73 I 86 11101100 236
// 78 N 63 11101101 237
// 79 O 64 11101110 238
// 82 R 64 11101111 239
// 83 S 76 11110000 240
// 84 T 65 11110001 241
// 107 k 67 11110010 242
// 113 q 61 11110011 243
// 119 w 108 11110100 244
// 10 \n 28 111101010 490
// 13 \r 27 111101011 491
// 40 ( 31 111101100 492
// 41 ) 31 111101101 493
// 44 , 34 111101110 494
// 45 - 41 111101111 495
// 47 / 29 111110000 496
// 50 2 49 111110001 497
// 53 5 30 111110010 498
// 66 B 45 111110011 499
// 70 F 35 111110100 500
// 71 G 27 111110101 501
// 77 M 36 111110110 502
// 85 U 51 111110111 503
// 106 j 41 111111000 504
// 51 3 27 1111110010 1010
// 52 4 20 1111110011 1011
// 54 6 22 1111110100 1012
// 56 8 16 1111110101 1013
// 58 : 13 1111110110 1014
// 76 L 27 1111110111 1015
// 87 W 17 1111111000 1016
// 122 z 24 1111111001 1017
// 42 * 9 11111110100 2036
// 55 7 10 11111110101 2037
// 57 9 13 11111110110 2038
// 60 < 9 11111110111 2039
// 62 > 9 11111111000 2040
// 72 H 12 11111111001 2041
// 86 V 11 11111111010 2042
// 88 X 11 11111111011 2043
// 33 ! 4 111111111000 4088
// 35 # 4 111111111001 4089
// 61 = 4 111111111010 4090
// 89 Y 5 111111111011 4091
// 96 ` 4 111111111100 4092
// 34 \" 4 1111111111010 8186
// 59 ; 2 1111111111011 8187
// 75 K 3 1111111111100 8188
// 123 { 2 1111111111101 8189
// 125 } 2 1111111111110 8190
// 74 J 1 11111111111110 16382
// 90 Z 1 11111111111111 16383
// length count {4: 9, 5: 7, 6: 4, 7: 7, 8: 15, 9: 15, 10: 8, 11: 8, 12: 5, 13: 5, 14: 2}
// values [' ', 'a', 'e', 'i', 'n', 'o', 'r', 's', 't', '_', 'c', 'd', 'l', 'm', 'p', 'u', 'b', 'f', 'g', 'y', "'", '0', 'E', 'P', 'h', 'v', 'x', '%', '.', '1', 'A', 'C', 'D', 'I', 'N', 'O', 'R', 'S', 'T', 'k', 'q', 'w', '\n', '\r', '(', ')', ',', '-', '/', '2', '5', 'B', 'F', 'G', 'M', 'U', 'j', '3', '4', '6', '8', ':', 'L', 'W', 'z', '*', '7', '9', '<', '>', 'H', 'V', 'X', '!', '#', '=', 'Y', '`', '"', ';', 'K', '{', '}', 'J', 'Z'] lengths 15 bytearray(b'\x00\x00\x00\t\x07\x04\x07\x0f\x0f\x08\x08\x05\x05\x02\x00')
// estimated total memory size 92229
// [' ', 'a', 'e', 'i', 'n', 'o', 'r', 's', 't', '_', 'c', 'd', 'l', 'm', 'p', 'u', 'b', 'f', 'g', 'y', "'", '0', 'E', 'P', 'h', 'v', 'x', '%', '.', '1', 'A', 'C', 'D', 'I', 'N', 'O', 'R', 'S', 'T', 'k', 'q', 'w', '\n', '\r', '(', ')', ',', '-', '/', '2', '5', 'B', 'F', 'G', 'M', 'U', 'j', '3', '4', '6', '8', ':', 'L', 'W', 'z', '*', '7', '9', '<', '>', 'H', 'V', 'X', '!', '#', '=', 'Y', '`', '"', ';', 'K', '{', '}', 'J', 'Z'] bytearray(b'\x00\x00\x00\t\x07\x04\x07\x0f\x0f\x08\x08\x05\x05\x02\x00')
// This file was automatically generated by makeqstrdata.py

QDEF(MP_QSTR_NULL, (const byte*)"\x00\x00" "")
QDEF(MP_QSTR_, (const byte*)"\x05\x00" "")
QDEF(MP_QSTR___dir__, (const byte*)"\x7a\x07" "__dir__")
QDEF(MP_QSTR___abs__, (const byte*)"\x95\x07" "__abs__")
QDEF(MP_QSTR___add__, (const byte*)"\xc4\x07" "__add__")
QDEF(MP_QSTR___and__, (const byte*)"\x0e\x07" "__and__")
QDEF(MP_QSTR___bool__, (const byte*)"\x2b\x08" "__bool__")
QDEF(MP_QSTR___build_class__, (const byte*)"\x42\x0f" "__build_class__")
QDEF(MP_QSTR___bytes__, (const byte*)"\xdc\x09" "__bytes__")
QDEF(MP_QSTR___call__, (const byte*)"\xa7\x08" "__call__")
QDEF(MP_QSTR___class__, (const byte*)"\x2b\x09" "__class__")
QDEF(MP_QSTR___contains__, (const byte*)"\xc6\x0c" "__contains__")
QDEF(MP_QSTR___del__, (const byte*)"\x68\x07" "__del__")
QDEF(MP_QSTR___delete__, (const byte*)"\xdc\x0a" "__delete__")
QDEF(MP_QSTR___delitem__, (const byte*)"\xfd\x0b" "__delitem__")
QDEF(MP_QSTR___dict__, (const byte*)"\x7f\x08" "__dict__")
QDEF(MP_QSTR___divmod__, (const byte*)"\x78\x0a" "__divmod__")
QDEF(MP_QSTR___enter__, (const byte*)"\x6d\x09" "__enter__")
QDEF(MP_QSTR___eq__, (const byte*)"\x71\x06" "__eq__")
QDEF(MP_QSTR___exit__, (const byte*)"\x45\x08" "__exit__")
QDEF(MP_QSTR___file__, (const byte*)"\x03\x08" "__file__")
QDEF(MP_QSTR___floordiv__, (const byte*)"\x46\x0c" "__floordiv__")
QDEF(MP_QSTR___func__, (const byte*)"\x5b\x08" "__func__")
QDEF(MP_QSTR___ge__, (const byte*)"\xa7\x06" "__ge__")
QDEF(MP_QSTR___get__, (const byte*)"\xb3\x07" "__get__")
QDEF(MP_QSTR___getattr__, (const byte*)"\x40\x0b" "__getattr__")
QDEF(MP_QSTR___getitem__, (const byte*)"\x26\x0b" "__getitem__")
QDEF(MP_QSTR___gt__, (const byte*)"\xb6\x06" "__gt__")
QDEF(MP_QSTR___hash__, (const byte*)"\xf7\x08" "__hash__")
QDEF(MP_QSTR___iadd__, (const byte*)"\x6d\x08" "__iadd__")
QDEF(MP_QSTR___import__, (const byte*)"\x38\x0a" "__import__")
QDEF(MP_QSTR___init__, (const byte*)"\x5f\x08" "__init__")
QDEF(MP_QSTR___invert__, (const byte*)"\xf7\x0a" "__invert__")
QDEF(MP_QSTR___isub__, (const byte*)"\x08\x08" "__isub__")
QDEF(MP_QSTR___iter__, (const byte*)"\xcf\x08" "__iter__")
QDEF(MP_QSTR___le__, (const byte*)"\xcc\x06" "__le__")
QDEF(MP_QSTR___len__, (const byte*)"\xe2\x07" "__len__")
QDEF(MP_QSTR___lshift__, (const byte*)"\x09\x0a" "__lshift__")
QDEF(MP_QSTR___lt__, (const byte*)"\x5d\x06" "__lt__")
QDEF(MP_QSTR___main__, (const byte*)"\x8e\x08" "__main__")
QDEF(MP_QSTR___mod__, (const byte*)"\x63\x07" "__mod__")
QDEF(MP_QSTR___module__, (const byte*)"\xff\x0a" "__module__")
QDEF(MP_QSTR___mul__, (const byte*)"\x31\x07" "__mul__")
QDEF(MP_QSTR___name__, (const byte*)"\xe2\x08" "__name__")
QDEF(MP_QSTR___neg__, (const byte*)"\x69\x07" "__neg__")
QDEF(MP_QSTR___new__, (const byte*)"\x79\x07" "__new__")
QDEF(MP_QSTR___next__, (const byte*)"\x02\x08" "__next__")
QDEF(MP_QSTR___or__, (const byte*)"\x38\x06" "__or__")
QDEF(MP_QSTR___path__, (const byte*)"\xc8\x08" "__path__")
QDEF(MP_QSTR___pos__, (const byte*)"\x29\x07" "__pos__")
QDEF(MP_QSTR___pow__, (const byte*)"\x2d\x07" "__pow__")
QDEF(MP_QSTR___qualname__, (const byte*)"\x6b\x0c" "__qualname__")
QDEF(MP_QSTR___radd__, (const byte*)"\x16\x08" "__radd__")
QDEF(MP_QSTR___rand__, (const byte*)"\xdc\x08" "__rand__")
QDEF(MP_QSTR___repl_print__, (const byte*)"\x01\x0e" "__repl_print__")
QDEF(MP_QSTR___repr__, (const byte*)"\x10\x08" "__repr__")
QDEF(MP_QSTR___reversed__, (const byte*)"\x61\x0c" "__reversed__")
QDEF(MP_QSTR___rfloordiv__, (const byte*)"\x54\x0d" "__rfloordiv__")
QDEF(MP_QSTR___rlshift__, (const byte*)"\x1b\x0b" "__rlshift__")
QDEF(MP_QSTR___rmod__, (const byte*)"\x31\x08" "__rmod__")
QDEF(MP_QSTR___rmul__, (const byte*)"\x63\x08" "__rmul__")
QDEF(MP_QSTR___ror__, (const byte*)"\x2a\x07" "__ror__")
QDEF(MP_QSTR___rpow__, (const byte*)"\xff\x08" "__rpow__")
QDEF(MP_QSTR___rrshift__, (const byte*)"\xc5\x0b" "__rrshift__")
QDEF(MP_QSTR___rshift__, (const byte*)"\x57\x0a" "__rshift__")
QDEF(MP_QSTR___rsub__, (const byte*)"\x73\x08" "__rsub__")
QDEF(MP_QSTR___rtruediv__, (const byte*)"\x5a\x0c" "__rtruediv__")
QDEF(MP_QSTR___rxor__, (const byte*)"\xf2\x08" "__rxor__")
QDEF(MP_QSTR___set__, (const byte*)"\xa7\x07" "__set__")
QDEF(MP_QSTR___setitem__, (const byte*)"\x32\x0b" "__setitem__")
QDEF(MP_QSTR___str__, (const byte*)"\xd0\x07" "__str__")
QDEF(MP_QSTR___sub__, (const byte*)"\x21\x07" "__sub__")
QDEF(MP_QSTR___traceback__, (const byte*)"\x4f\x0d" "__traceback__")
QDEF(MP_QSTR___truediv__, (const byte*)"\x88\x0b" "__truediv__")
QDEF(MP_QSTR___version__, (const byte*)"\x3f\x0b" "__version__")
QDEF(MP_QSTR___xor__, (const byte*)"\x20\x07" "__xor__")
QDEF(MP_QSTR__star_, (const byte*)"\x8f\x01" "*")
QDEF(MP_QSTR__, (const byte*)"\xfa\x01" "_")
QDEF(MP_QSTR__slash_, (const byte*)"\x8a\x01" "/")
QDEF(MP_QSTR__percent__hash_o, (const byte*)"\x6c\x03" "%#o")
QDEF(MP_QSTR__percent__hash_x, (const byte*)"\x7b\x03" "%#x")
QDEF(MP_QSTR__brace_open__colon__hash_b_brace_close_, (const byte*)"\x58\x05" "{:#b}")
QDEF(MP_QSTR__space_, (const byte*)"\x85\x01" " ")
QDEF(MP_QSTR__0x0a_, (const byte*)"\xaf\x01" "\x0a")
QDEF(MP_QSTR_maximum_space_recursion_space_depth_space_exceeded, (const byte*)"\x73\x20" "maximum recursion depth exceeded")
QDEF(MP_QSTR__lt_module_gt_, (const byte*)"\xbd\x08" "<module>")
QDEF(MP_QSTR__lt_lambda_gt_, (const byte*)"\x80\x08" "<lambda>")
QDEF(MP_QSTR__lt_listcomp_gt_, (const byte*)"\xd4\x0a" "<listcomp>")
QDEF(MP_QSTR__lt_dictcomp_gt_, (const byte*)"\xcc\x0a" "<dictcomp>")
QDEF(MP_QSTR__lt_setcomp_gt_, (const byte*)"\x54\x09" "<setcomp>")
QDEF(MP_QSTR__lt_genexpr_gt_, (const byte*)"\x34\x09" "<genexpr>")
QDEF(MP_QSTR__lt_string_gt_, (const byte*)"\x52\x08" "<string>")
QDEF(MP_QSTR__lt_stdin_gt_, (const byte*)"\xe3\x07" "<stdin>")
QDEF(MP_QSTR_utf_hyphen_8, (const byte*)"\xb7\x05" "utf-8")
QDEF(MP_QSTR__dot_frozen, (const byte*)"\x81\x07" ".frozen")
QDEF(MP_QSTR__slash_lib, (const byte*)"\x8d\x04" "/lib")
QDEF(MP_QSTR_A0, (const byte*)"\x54\x02" "A0")
QDEF(MP_QSTR_A1, (const byte*)"\x55\x02" "A1")
QDEF(MP_QSTR_A2, (const byte*)"\x56\x02" "A2")
QDEF(MP_QSTR_A3, (const byte*)"\x57\x02" "A3")
QDEF(MP_QSTR_A4, (const byte*)"\x50\x02" "A4")
QDEF(MP_QSTR_A5, (const byte*)"\x51\x02" "A5")
QDEF(MP_QSTR_AUDIO_INT, (const byte*)"\x1f\x09" "AUDIO_INT")
QDEF(MP_QSTR_AUDIO_SCL, (const byte*)"\x70\x09" "AUDIO_SCL")
QDEF(MP_QSTR_AUDIO_SDA, (const byte*)"\x5a\x09" "AUDIO_SDA")
QDEF(MP_QSTR_AnalogIn, (const byte*)"\xc8\x08" "AnalogIn")
QDEF(MP_QSTR_AnalogOut, (const byte*)"\x41\x09" "AnalogOut")
QDEF(MP_QSTR_ArithmeticError, (const byte*)"\x2d\x0f" "ArithmeticError")
QDEF(MP_QSTR_AssertionError, (const byte*)"\x97\x0e" "AssertionError")
QDEF(MP_QSTR_AttributeError, (const byte*)"\x21\x0e" "AttributeError")
QDEF(MP_QSTR_BGR, (const byte*)"\xd2\x03" "BGR")
QDEF(MP_QSTR_BOOTLOADER, (const byte*)"\xe2\x0a" "BOOTLOADER")
QDEF(MP_QSTR_BaseException, (const byte*)"\x07\x0d" "BaseException")
QDEF(MP_QSTR_BytesIO, (const byte*)"\x1a\x07" "BytesIO")
QDEF(MP_QSTR_C, (const byte*)"\xe6\x01" "C")
QDEF(MP_QSTR_D0, (const byte*)"\x31\x02" "D0")
QDEF(MP_QSTR_D1, (const byte*)"\x30\x02" "D1")
QDEF(MP_QSTR_D10, (const byte*)"\x01\x03" "D10")
QDEF(MP_QSTR_D11, (const byte*)"\x01\x03" "D11")
QDEF(MP_QSTR_D12, (const byte*)"\x02\x03" "D12")
QDEF(MP_QSTR_D13, (const byte*)"\x03\x03" "D13")
QDEF(MP_QSTR_D14, (const byte*)"\x04\x03" "D14")
QDEF(MP_QSTR_D15, (const byte*)"\x05\x03" "D15")
QDEF(MP_QSTR_D16, (const byte*)"\x06\x03" "D16")
QDEF(MP_QSTR_D17, (const byte*)"\x07\x03" "D17")
QDEF(MP_QSTR_D18, (const byte*)"\x08\x03" "D18")
QDEF(MP_QSTR_D19, (const byte*)"\x09\x03" "D19")
QDEF(MP_QSTR_D2, (const byte*)"\x33\x02" "D2")
QDEF(MP_QSTR_D20, (const byte*)"\xa3\x03" "D20")
QDEF(MP_QSTR_D21, (const byte*)"\xa2\x03" "D21")
QDEF(MP_QSTR_D22, (const byte*)"\xa1\x03" "D22")
QDEF(MP_QSTR_D23, (const byte*)"\xa0\x03" "D23")
QDEF(MP_QSTR_D24, (const byte*)"\xa7\x03" "D24")
QDEF(MP_QSTR_D25, (const byte*)"\xa6\x03" "D25")
QDEF(MP_QSTR_D3, (const byte*)"\x32\x02" "D3")
QDEF(MP_QSTR_D4, (const byte*)"\x35\x02" "D4")
QDEF(MP_QSTR_D5, (const byte*)"\x34\x02" "D5")
QDEF(MP_QSTR_D6, (const byte*)"\x37\x02" "D6")
QDEF(MP_QSTR_D7, (const byte*)"\x36\x02" "D7")
QDEF(MP_QSTR_D8, (const byte*)"\x39\x02" "D8")
QDEF(MP_QSTR_D9, (const byte*)"\x38\x02" "D9")
QDEF(MP_QSTR_DEBUG, (const byte*)"\x34\x05" "DEBUG")
QDEF(MP_QSTR_DOWN, (const byte*)"\x37\x04" "DOWN")
QDEF(MP_QSTR_Device, (const byte*)"\x1d\x06" "Device")
QDEF(MP_QSTR_DigitalInOut, (const byte*)"\xf6\x0c" "DigitalInOut")
QDEF(MP_QSTR_Direction, (const byte*)"\x40\x09" "Direction")
QDEF(MP_QSTR_DriveMode, (const byte*)"\xaa\x09" "DriveMode")
QDEF(MP_QSTR_EACCES, (const byte*)"\x37\x06" "EACCES")
QDEF(MP_QSTR_EADDRINUSE, (const byte*)"\x17\x0a" "EADDRINUSE")
QDEF(MP_QSTR_EAGAIN, (const byte*)"\x20\x06" "EAGAIN")
QDEF(MP_QSTR_EALREADY, (const byte*)"\x46\x08" "EALREADY")
QDEF(MP_QSTR_EBADF, (const byte*)"\x61\x05" "EBADF")
QDEF(MP_QSTR_ECONNABORTED, (const byte*)"\x27\x0c" "ECONNABORTED")
QDEF(MP_QSTR_ECONNREFUSED, (const byte*)"\x3a\x0c" "ECONNREFUSED")
QDEF(MP_QSTR_ECONNRESET, (const byte*)"\x19\x0a" "ECONNRESET")
QDEF(MP_QSTR_EEXIST, (const byte*)"\x53\x06" "EEXIST")
QDEF(MP_QSTR_EHOSTUNREACH, (const byte*)"\x86\x0c" "EHOSTUNREACH")
QDEF(MP_QSTR_EINPROGRESS, (const byte*)"\x9a\x0b" "EINPROGRESS")
QDEF(MP_QSTR_EINVAL, (const byte*)"\x5c\x06" "EINVAL")
QDEF(MP_QSTR_EIO, (const byte*)"\x86\x03" "EIO")
QDEF(MP_QSTR_EISDIR, (const byte*)"\xa5\x06" "EISDIR")
QDEF(MP_QSTR_ENOBUFS, (const byte*)"\xe3\x07" "ENOBUFS")
QDEF(MP_QSTR_ENODEV, (const byte*)"\xb6\x06" "ENODEV")
QDEF(MP_QSTR_ENOENT, (const byte*)"\x5e\x06" "ENOENT")
QDEF(MP_QSTR_ENOMEM, (const byte*)"\xa4\x06" "ENOMEM")
QDEF(MP_QSTR_ENOTCONN, (const byte*)"\x79\x08" "ENOTCONN")
QDEF(MP_QSTR_EOFError, (const byte*)"\x91\x08" "EOFError")
QDEF(MP_QSTR_EOPNOTSUPP, (const byte*)"\xac\x0a" "EOPNOTSUPP")
QDEF(MP_QSTR_EPERM, (const byte*)"\xea\x05" "EPERM")
QDEF(MP_QSTR_ETIMEDOUT, (const byte*)"\xff\x09" "ETIMEDOUT")
QDEF(MP_QSTR_EVEN, (const byte*)"\xdd\x04" "EVEN")
QDEF(MP_QSTR_EXT_RST, (const byte*)"\xa6\x07" "EXT_RST")
QDEF(MP_QSTR_EXT_SCL, (const byte*)"\xaf\x07" "EXT_SCL")
QDEF(MP_QSTR_EXT_SDA, (const byte*)"\x45\x07" "EXT_SDA")
QDEF(MP_QSTR_Ellipsis, (const byte*)"\xf0\x08" "Ellipsis")
QDEF(MP_QSTR_Exception, (const byte*)"\xf2\x09" "Exception")
QDEF(MP_QSTR_FileIO, (const byte*)"\xc5\x06" "FileIO")
QDEF(MP_QSTR_Flash, (const byte*)"\x95\x05" "Flash")
QDEF(MP_QSTR_GamePad, (const byte*)"\x3e\x07" "GamePad")
QDEF(MP_QSTR_GeneratorExit, (const byte*)"\x16\x0d" "GeneratorExit")
QDEF(MP_QSTR_I2C, (const byte*)"\x5d\x03" "I2C")
QDEF(MP_QSTR_INPUT, (const byte*)"\x53\x05" "INPUT")
QDEF(MP_QSTR_ImportError, (const byte*)"\x20\x0b" "ImportError")
QDEF(MP_QSTR_IndentationError, (const byte*)"\x5c\x10" "IndentationError")
QDEF(MP_QSTR_IndexError, (const byte*)"\x83\x0a" "IndexError")
QDEF(MP_QSTR_KeyError, (const byte*)"\xea\x08" "KeyError")
QDEF(MP_QSTR_KeyboardInterrupt, (const byte*)"\xaf\x11" "KeyboardInterrupt")
QDEF(MP_QSTR_LCD_BL_CTRL, (const byte*)"\xc9\x0b" "LCD_BL_CTRL")
QDEF(MP_QSTR_LCD_INT, (const byte*)"\xe2\x07" "LCD_INT")
QDEF(MP_QSTR_LCD_SCL, (const byte*)"\x8d\x07" "LCD_SCL")
QDEF(MP_QSTR_LCD_SDA, (const byte*)"\x27\x07" "LCD_SDA")
QDEF(MP_QSTR_LED1, (const byte*)"\xb9\x04" "LED1")
QDEF(MP_QSTR_LED2, (const byte*)"\xba\x04" "LED2")
QDEF(MP_QSTR_LED3, (const byte*)"\xbb\x04" "LED3")
QDEF(MP_QSTR_LookupError, (const byte*)"\xff\x0b" "LookupError")
QDEF(MP_QSTR_M, (const byte*)"\xe8\x01" "M")
QDEF(MP_QSTR_MISO, (const byte*)"\x9d\x04" "MISO")
QDEF(MP_QSTR_MOSI, (const byte*)"\x1d\x04" "MOSI")
QDEF(MP_QSTR_MemoryError, (const byte*)"\xdc\x0b" "MemoryError")
QDEF(MP_QSTR_MpyError, (const byte*)"\x39\x08" "MpyError")
QDEF(MP_QSTR_NORMAL, (const byte*)"\xf6\x06" "NORMAL")
QDEF(MP_QSTR_NameError, (const byte*)"\xba\x09" "NameError")
QDEF(MP_QSTR_NoneType, (const byte*)"\x17\x08" "NoneType")
QDEF(MP_QSTR_NotImplementedError, (const byte*)"\xc6\x13" "NotImplementedError")
QDEF(MP_QSTR_ODD, (const byte*)"\x6a\x03" "ODD")
QDEF(MP_QSTR_OPEN_DRAIN, (const byte*)"\x5e\x0a" "OPEN_DRAIN")
QDEF(MP_QSTR_OSError, (const byte*)"\xa1\x07" "OSError")
QDEF(MP_QSTR_OTG_FS_OVER_CURRENT, (const byte*)"\xf4\x13" "OTG_FS_OVER_CURRENT")
QDEF(MP_QSTR_OTG_FS_POWER, (const byte*)"\xf3\x0c" "OTG_FS_POWER")
QDEF(MP_QSTR_OTG_HS_OVER_CURRENT, (const byte*)"\x7a\x13" "OTG_HS_OVER_CURRENT")
QDEF(MP_QSTR_OUTPUT, (const byte*)"\xda\x06" "OUTPUT")
QDEF(MP_QSTR_OneWire, (const byte*)"\x68\x07" "OneWire")
QDEF(MP_QSTR_OrderedDict, (const byte*)"\xf0\x0b" "OrderedDict")
QDEF(MP_QSTR_OverflowError, (const byte*)"\x81\x0d" "OverflowError")
QDEF(MP_QSTR_PA00, (const byte*)"\xd4\x04" "PA00")
QDEF(MP_QSTR_PA01, (const byte*)"\xd5\x04" "PA01")
QDEF(MP_QSTR_PA02, (const byte*)"\xd6\x04" "PA02")
QDEF(MP_QSTR_PA03, (const byte*)"\xd7\x04" "PA03")
QDEF(MP_QSTR_PA04, (const byte*)"\xd0\x04" "PA04")
QDEF(MP_QSTR_PA05, (const byte*)"\xd1\x04" "PA05")
QDEF(MP_QSTR_PA06, (const byte*)"\xd2\x04" "PA06")
QDEF(MP_QSTR_PA07, (const byte*)"\xd3\x04" "PA07")
QDEF(MP_QSTR_PA08, (const byte*)"\xdc\x04" "PA08")
QDEF(MP_QSTR_PA09, (const byte*)"\xdd\x04" "PA09")
QDEF(MP_QSTR_PA10, (const byte*)"\x35\x04" "PA10")
QDEF(MP_QSTR_PA11, (const byte*)"\x34\x04" "PA11")
QDEF(MP_QSTR_PA12, (const byte*)"\x37\x04" "PA12")
QDEF(MP_QSTR_PA13, (const byte*)"\x36\x04" "PA13")
QDEF(MP_QSTR_PA14, (const byte*)"\x31\x04" "PA14")
QDEF(MP_QSTR_PA15, (const byte*)"\x30\x04" "PA15")
QDEF(MP_QSTR_PB00, (const byte*)"\x57\x04" "PB00")
QDEF(MP_QSTR_PB01, (const byte*)"\x56\x04" "PB01")
QDEF(MP_QSTR_PB02, (const byte*)"\x55\x04" "PB02")
QDEF(MP_QSTR_PB03, (const byte*)"\x54\x04" "PB03")
QDEF(MP_QSTR_PB04, (const byte*)"\x53\x04" "PB04")
QDEF(MP_QSTR_PB05, (const byte*)"\x52\x04" "PB05")
QDEF(MP_QSTR_PB06, (const byte*)"\x51\x04" "PB06")
QDEF(MP_QSTR_PB07, (const byte*)"\x50\x04" "PB07")
QDEF(MP_QSTR_PB08, (const byte*)"\x5f\x04" "PB08")
QDEF(MP_QSTR_PB09, (const byte*)"\x5e\x04" "PB09")
QDEF(MP_QSTR_PB10, (const byte*)"\x76\x04" "PB10")
QDEF(MP_QSTR_PB11, (const byte*)"\x77\x04" "PB11")
QDEF(MP_QSTR_PB12, (const byte*)"\x74\x04" "PB12")
QDEF(MP_QSTR_PB13, (const byte*)"\x75\x04" "PB13")
QDEF(MP_QSTR_PB14, (const byte*)"\x72\x04" "PB14")
QDEF(MP_QSTR_PB15, (const byte*)"\x73\x04" "PB15")
QDEF(MP_QSTR_PC00, (const byte*)"\x56\x04" "PC00")
QDEF(MP_QSTR_PC01, (const byte*)"\x57\x04" "PC01")
QDEF(MP_QSTR_PC02, (const byte*)"\x54\x04" "PC02")
QDEF(MP_QSTR_PC03, (const byte*)"\x55\x04" "PC03")
QDEF(MP_QSTR_PC04, (const byte*)"\x52\x04" "PC04")
QDEF(MP_QSTR_PC05, (const byte*)"\x53\x04" "PC05")
QDEF(MP_QSTR_PC06, (const byte*)"\x50\x04" "PC06")
QDEF(MP_QSTR_PC07, (const byte*)"\x51\x04" "PC07")
QDEF(MP_QSTR_PC08, (const byte*)"\x5e\x04" "PC08")
QDEF(MP_QSTR_PC09, (const byte*)"\x5f\x04" "PC09")
QDEF(MP_QSTR_PC10, (const byte*)"\xb7\x04" "PC10")
QDEF(MP_QSTR_PC11, (const byte*)"\xb6\x04" "PC11")
QDEF(MP_QSTR_PC12, (const byte*)"\xb5\x04" "PC12")
QDEF(MP_QSTR_PC13, (const byte*)"\xb4\x04" "PC13")
QDEF(MP_QSTR_PD00, (const byte*)"\xd1\x04" "PD00")
QDEF(MP_QSTR_PD01, (const byte*)"\xd0\x04" "PD01")
QDEF(MP_QSTR_PD02, (const byte*)"\xd3\x04" "PD02")
QDEF(MP_QSTR_PD03, (const byte*)"\xd2\x04" "PD03")
QDEF(MP_QSTR_PD04, (const byte*)"\xd5\x04" "PD04")
QDEF(MP_QSTR_PD05, (const byte*)"\xd4\x04" "PD05")
QDEF(MP_QSTR_PD06, (const byte*)"\xd7\x04" "PD06")
QDEF(MP_QSTR_PD07, (const byte*)"\xd6\x04" "PD07")
QDEF(MP_QSTR_PD08, (const byte*)"\xd9\x04" "PD08")
QDEF(MP_QSTR_PD09, (const byte*)"\xd8\x04" "PD09")
QDEF(MP_QSTR_PD10, (const byte*)"\xf0\x04" "PD10")
QDEF(MP_QSTR_PD11, (const byte*)"\xf1\x04" "PD11")
QDEF(MP_QSTR_PD12, (const byte*)"\xf2\x04" "PD12")
QDEF(MP_QSTR_PD13, (const byte*)"\xf3\x04" "PD13")
QDEF(MP_QSTR_PD14, (const byte*)"\xf4\x04" "PD14")
QDEF(MP_QSTR_PD15, (const byte*)"\xf5\x04" "PD15")
QDEF(MP_QSTR_PE00, (const byte*)"\xd0\x04" "PE00")
QDEF(MP_QSTR_PE01, (const byte*)"\xd1\x04" "PE01")
QDEF(MP_QSTR_PE02, (const byte*)"\xd2\x04" "PE02")
QDEF(MP_QSTR_PE03, (const byte*)"\xd3\x04" "PE03")
QDEF(MP_QSTR_PE04, (const byte*)"\xd4\x04" "PE04")
QDEF(MP_QSTR_PE05, (const byte*)"\xd5\x04" "PE05")
QDEF(MP_QSTR_PE06, (const byte*)"\xd6\x04" "PE06")
QDEF(MP_QSTR_PE07, (const byte*)"\xd7\x04" "PE07")
QDEF(MP_QSTR_PE08, (const byte*)"\xd8\x04" "PE08")
QDEF(MP_QSTR_PE09, (const byte*)"\xd9\x04" "PE09")
QDEF(MP_QSTR_PE10, (const byte*)"\x31\x04" "PE10")
QDEF(MP_QSTR_PE11, (const byte*)"\x30\x04" "PE11")
QDEF(MP_QSTR_PE12, (const byte*)"\x33\x04" "PE12")
QDEF(MP_QSTR_PE13, (const byte*)"\x32\x04" "PE13")
QDEF(MP_QSTR_PE14, (const byte*)"\x35\x04" "PE14")
QDEF(MP_QSTR_PE15, (const byte*)"\x34\x04" "PE15")
QDEF(MP_QSTR_PF00, (const byte*)"\x53\x04" "PF00")
QDEF(MP_QSTR_PF01, (const byte*)"\x52\x04" "PF01")
QDEF(MP_QSTR_PF02, (const byte*)"\x51\x04" "PF02")
QDEF(MP_QSTR_PF03, (const byte*)"\x50\x04" "PF03")
QDEF(MP_QSTR_PF04, (const byte*)"\x57\x04" "PF04")
QDEF(MP_QSTR_PF05, (const byte*)"\x56\x04" "PF05")
QDEF(MP_QSTR_PF06, (const byte*)"\x55\x04" "PF06")
QDEF(MP_QSTR_PF07, (const byte*)"\x54\x04" "PF07")
QDEF(MP_QSTR_PF08, (const byte*)"\x5b\x04" "PF08")
QDEF(MP_QSTR_PF09, (const byte*)"\x5a\x04" "PF09")
QDEF(MP_QSTR_PF10, (const byte*)"\x72\x04" "PF10")
QDEF(MP_QSTR_PF11, (const byte*)"\x73\x04" "PF11")
QDEF(MP_QSTR_PF12, (const byte*)"\x70\x04" "PF12")
QDEF(MP_QSTR_PF13, (const byte*)"\x71\x04" "PF13")
QDEF(MP_QSTR_PF14, (const byte*)"\x76\x04" "PF14")
QDEF(MP_QSTR_PF15, (const byte*)"\x77\x04" "PF15")
QDEF(MP_QSTR_PG00, (const byte*)"\x52\x04" "PG00")
QDEF(MP_QSTR_PG01, (const byte*)"\x53\x04" "PG01")
QDEF(MP_QSTR_PG02, (const byte*)"\x50\x04" "PG02")
QDEF(MP_QSTR_PG03, (const byte*)"\x51\x04" "PG03")
QDEF(MP_QSTR_PG04, (const byte*)"\x56\x04" "PG04")
QDEF(MP_QSTR_PG05, (const byte*)"\x57\x04" "PG05")
QDEF(MP_QSTR_PG06, (const byte*)"\x54\x04" "PG06")
QDEF(MP_QSTR_PG07, (const byte*)"\x55\x04" "PG07")
QDEF(MP_QSTR_PG08, (const byte*)"\x5a\x04" "PG08")
QDEF(MP_QSTR_PG09, (const byte*)"\x5b\x04" "PG09")
QDEF(MP_QSTR_PG10, (const byte*)"\xb3\x04" "PG10")
QDEF(MP_QSTR_PG11, (const byte*)"\xb2\x04" "PG11")
QDEF(MP_QSTR_PG12, (const byte*)"\xb1\x04" "PG12")
QDEF(MP_QSTR_PG13, (const byte*)"\xb0\x04" "PG13")
QDEF(MP_QSTR_PG14, (const byte*)"\xb7\x04" "PG14")
QDEF(MP_QSTR_PG15, (const byte*)"\xb6\x04" "PG15")
QDEF(MP_QSTR_PUSH_PULL, (const byte*)"\x81\x09" "PUSH_PULL")
QDEF(MP_QSTR_PWMOut, (const byte*)"\xc1\x06" "PWMOut")
QDEF(MP_QSTR_Parity, (const byte*)"\x22\x06" "Parity")
QDEF(MP_QSTR_Pin, (const byte*)"\x12\x03" "Pin")
QDEF(MP_QSTR_PixelBuf, (const byte*)"\xfc\x08" "PixelBuf")
QDEF(MP_QSTR_PortIn, (const byte*)"\xfb\x06" "PortIn")
QDEF(MP_QSTR_PortOut, (const byte*)"\x92\x07" "PortOut")
QDEF(MP_QSTR_Processor, (const byte*)"\x13\x09" "Processor")
QDEF(MP_QSTR_Pull, (const byte*)"\x60\x04" "Pull")
QDEF(MP_QSTR_PulseIn, (const byte*)"\xfd\x07" "PulseIn")
QDEF(MP_QSTR_PulseOut, (const byte*)"\xd4\x08" "PulseOut")
QDEF(MP_QSTR_ReloadException, (const byte*)"\x03\x0f" "ReloadException")
QDEF(MP_QSTR_RunMode, (const byte*)"\x8f\x07" "RunMode")
QDEF(MP_QSTR_Runtime, (const byte*)"\xb9\x07" "Runtime")
QDEF(MP_QSTR_RuntimeError, (const byte*)"\x61\x0c" "RuntimeError")
QDEF(MP_QSTR_SAFE_MODE, (const byte*)"\x08\x09" "SAFE_MODE")
QDEF(MP_QSTR_SD_SW, (const byte*)"\x49\x05" "SD_SW")
QDEF(MP_QSTR_SPI, (const byte*)"\xef\x03" "SPI")
QDEF(MP_QSTR_SPI_B_MOSI, (const byte*)"\x55\x0a" "SPI_B_MOSI")
QDEF(MP_QSTR_SPI_B_NSS, (const byte*)"\x03\x09" "SPI_B_NSS")
QDEF(MP_QSTR_SPI_B_SCK, (const byte*)"\x96\x09" "SPI_B_SCK")
QDEF(MP_QSTR_SW, (const byte*)"\xe1\x02" "SW")
QDEF(MP_QSTR_StopIteration, (const byte*)"\xea\x0d" "StopIteration")
QDEF(MP_QSTR_StringIO, (const byte*)"\x76\x08" "StringIO")
QDEF(MP_QSTR_SyntaxError, (const byte*)"\x94\x0b" "SyntaxError")
QDEF(MP_QSTR_SystemExit, (const byte*)"\x20\x0a" "SystemExit")
QDEF(MP_QSTR_TP1, (const byte*)"\x50\x03" "TP1")
QDEF(MP_QSTR_TP2, (const byte*)"\x53\x03" "TP2")
QDEF(MP_QSTR_TP3, (const byte*)"\x52\x03" "TP3")
QDEF(MP_QSTR_TextIOWrapper, (const byte*)"\xad\x0d" "TextIOWrapper")
QDEF(MP_QSTR_TimeoutError, (const byte*)"\x66\x0c" "TimeoutError")
QDEF(MP_QSTR_TouchIn, (const byte*)"\x67\x07" "TouchIn")
QDEF(MP_QSTR_TypeError, (const byte*)"\x25\x09" "TypeError")
QDEF(MP_QSTR_UART, (const byte*)"\xb7\x04" "UART")
QDEF(MP_QSTR_UART2_CTS, (const byte*)"\x5e\x09" "UART2_CTS")
QDEF(MP_QSTR_UART2_RTS, (const byte*)"\x8f\x09" "UART2_RTS")
QDEF(MP_QSTR_UART2_RX, (const byte*)"\x50\x08" "UART2_RX")
QDEF(MP_QSTR_UART2_TX, (const byte*)"\x96\x08" "UART2_TX")
QDEF(MP_QSTR_UART6_RX, (const byte*)"\xd4\x08" "UART6_RX")
QDEF(MP_QSTR_UART6_TX, (const byte*)"\x12\x08" "UART6_TX")
QDEF(MP_QSTR_UP, (const byte*)"\xa0\x02" "UP")
QDEF(MP_QSTR_USB_DM, (const byte*)"\xb7\x06" "USB_DM")
QDEF(MP_QSTR_USB_DP, (const byte*)"\xaa\x06" "USB_DP")
QDEF(MP_QSTR_USB_ID, (const byte*)"\xd3\x06" "USB_ID")
QDEF(MP_QSTR_USB_VBUS, (const byte*)"\x0c\x08" "USB_VBUS")
QDEF(MP_QSTR_UnicodeError, (const byte*)"\x22\x0c" "UnicodeError")
QDEF(MP_QSTR_ValueError, (const byte*)"\x96\x0a" "ValueError")
QDEF(MP_QSTR_VfsFat, (const byte*)"\x15\x06" "VfsFat")
QDEF(MP_QSTR_ZeroDivisionError, (const byte*)"\xb6\x11" "ZeroDivisionError")
QDEF(MP_QSTR__os, (const byte*)"\x86\x03" "_os")
QDEF(MP_QSTR__pixelbuf, (const byte*)"\xc3\x09" "_pixelbuf")
QDEF(MP_QSTR__time, (const byte*)"\x0f\x05" "_time")
QDEF(MP_QSTR__transmit, (const byte*)"\xd0\x09" "_transmit")
QDEF(MP_QSTR_a, (const byte*)"\xc4\x01" "a")
QDEF(MP_QSTR_abs, (const byte*)"\x95\x03" "abs")
QDEF(MP_QSTR_acos, (const byte*)"\x1b\x04" "acos")
QDEF(MP_QSTR_acosh, (const byte*)"\x13\x05" "acosh")
QDEF(MP_QSTR_add, (const byte*)"\x44\x03" "add")
QDEF(MP_QSTR_address, (const byte*)"\x73\x07" "address")
QDEF(MP_QSTR_all, (const byte*)"\x44\x03" "all")
QDEF(MP_QSTR_analogio, (const byte*)"\x09\x08" "analogio")
QDEF(MP_QSTR_any, (const byte*)"\x13\x03" "any")
QDEF(MP_QSTR_append, (const byte*)"\x6b\x06" "append")
QDEF(MP_QSTR_arctan2, (const byte*)"\x1c\x07" "arctan2")
QDEF(MP_QSTR_argmax, (const byte*)"\xa5\x06" "argmax")
QDEF(MP_QSTR_argmin, (const byte*)"\xbb\x06" "argmin")
QDEF(MP_QSTR_args, (const byte*)"\xc2\x04" "args")
QDEF(MP_QSTR_argsort, (const byte*)"\x2b\x07" "argsort")
QDEF(MP_QSTR_argv, (const byte*)"\xc7\x04" "argv")
QDEF(MP_QSTR_around, (const byte*)"\x06\x06" "around")
QDEF(MP_QSTR_array, (const byte*)"\x7c\x05" "array")
QDEF(MP_QSTR_asin, (const byte*)"\x50\x04" "asin")
QDEF(MP_QSTR_asinh, (const byte*)"\x38\x05" "asinh")
QDEF(MP_QSTR_atan, (const byte*)"\x1f\x04" "atan")
QDEF(MP_QSTR_atan2, (const byte*)"\xcd\x05" "atan2")
QDEF(MP_QSTR_atanh, (const byte*)"\x97\x05" "atanh")
QDEF(MP_QSTR_auto_write, (const byte*)"\xe8\x0a" "auto_write")
QDEF(MP_QSTR_axis, (const byte*)"\x06\x04" "axis")
QDEF(MP_QSTR_baudrate, (const byte*)"\xf5\x08" "baudrate")
QDEF(MP_QSTR_bin, (const byte*)"\xe0\x03" "bin")
QDEF(MP_QSTR_bits, (const byte*)"\x49\x04" "bits")
QDEF(MP_QSTR_board, (const byte*)"\x7f\x05" "board")
QDEF(MP_QSTR_bool, (const byte*)"\xeb\x04" "bool")
QDEF(MP_QSTR_bound_method, (const byte*)"\x97\x0c" "bound_method")
QDEF(MP_QSTR_bpp, (const byte*)"\xc7\x03" "bpp")
QDEF(MP_QSTR_brightness, (const byte*)"\x4c\x0a" "brightness")
QDEF(MP_QSTR_buffer, (const byte*)"\xe5\x06" "buffer")
QDEF(MP_QSTR_buffer_in, (const byte*)"\xbd\x09" "buffer_in")
QDEF(MP_QSTR_buffer_out, (const byte*)"\x14\x0a" "buffer_out")
QDEF(MP_QSTR_buffering, (const byte*)"\x25\x09" "buffering")
QDEF(MP_QSTR_builtins, (const byte*)"\xf7\x08" "builtins")
QDEF(MP_QSTR_busio, (const byte*)"\x87\x05" "busio")
QDEF(MP_QSTR_bytearray, (const byte*)"\x76\x09" "bytearray")
QDEF(MP_QSTR_bytecode, (const byte*)"\x22\x08" "bytecode")
QDEF(MP_QSTR_byteorder, (const byte*)"\x61\x09" "byteorder")
QDEF(MP_QSTR_bytes, (const byte*)"\x5c\x05" "bytes")
QDEF(MP_QSTR_calcsize, (const byte*)"\x4d\x08" "calcsize")
QDEF(MP_QSTR_callable, (const byte*)"\x0d\x08" "callable")
QDEF(MP_QSTR_ceil, (const byte*)"\x06\x04" "ceil")
QDEF(MP_QSTR_center, (const byte*)"\x4e\x06" "center")
QDEF(MP_QSTR_chdir, (const byte*)"\xb1\x05" "chdir")
QDEF(MP_QSTR_choice, (const byte*)"\x2e\x06" "choice")
QDEF(MP_QSTR_cholesky, (const byte*)"\x89\x08" "cholesky")
QDEF(MP_QSTR_chr, (const byte*)"\xdc\x03" "chr")
QDEF(MP_QSTR_circuitpython, (const byte*)"\x02\x0d" "circuitpython")
QDEF(MP_QSTR_classmethod, (const byte*)"\xb4\x0b" "classmethod")
QDEF(MP_QSTR_clear, (const byte*)"\x7c\x05" "clear")
QDEF(MP_QSTR_clip, (const byte*)"\xd3\x04" "clip")
QDEF(MP_QSTR_clock, (const byte*)"\x2d\x05" "clock")
QDEF(MP_QSTR_close, (const byte*)"\x33\x05" "close")
QDEF(MP_QSTR_closure, (const byte*)"\x74\x07" "closure")
QDEF(MP_QSTR_collect, (const byte*)"\x9b\x07" "collect")
QDEF(MP_QSTR_collections, (const byte*)"\xe0\x0b" "collections")
QDEF(MP_QSTR_colorwheel, (const byte*)"\x0b\x0a" "colorwheel")
QDEF(MP_QSTR_compare, (const byte*)"\x22\x07" "compare")
QDEF(MP_QSTR_compile, (const byte*)"\xf4\x07" "compile")
QDEF(MP_QSTR_complex, (const byte*)"\xc5\x07" "complex")
QDEF(MP_QSTR_configure, (const byte*)"\x8d\x09" "configure")
QDEF(MP_QSTR_const, (const byte*)"\xc0\x05" "const")
QDEF(MP_QSTR_convolve, (const byte*)"\x41\x08" "convolve")
QDEF(MP_QSTR_copy, (const byte*)"\xe0\x04" "copy")
QDEF(MP_QSTR_copysign, (const byte*)"\x33\x08" "copysign")
QDEF(MP_QSTR_cos, (const byte*)"\x7a\x03" "cos")
QDEF(MP_QSTR_count, (const byte*)"\xa6\x05" "count")
QDEF(MP_QSTR_cpu, (const byte*)"\xc3\x03" "cpu")
QDEF(MP_QSTR_cts, (const byte*)"\x41\x03" "cts")
QDEF(MP_QSTR_ddof, (const byte*)"\xec\x04" "ddof")
QDEF(MP_QSTR_decimals, (const byte*)"\x1d\x08" "decimals")
QDEF(MP_QSTR_decode, (const byte*)"\xa9\x06" "decode")
QDEF(MP_QSTR_default, (const byte*)"\xce\x07" "default")
QDEF(MP_QSTR_degrees, (const byte*)"\x02\x07" "degrees")
QDEF(MP_QSTR_deinit, (const byte*)"\x9e\x06" "deinit")
QDEF(MP_QSTR_delattr, (const byte*)"\xdb\x07" "delattr")
QDEF(MP_QSTR_delay_us, (const byte*)"\xa9\x08" "delay_us")
QDEF(MP_QSTR_deleter, (const byte*)"\x6e\x07" "deleter")
QDEF(MP_QSTR_det, (const byte*)"\x70\x03" "det")
QDEF(MP_QSTR_devices, (const byte*)"\xae\x07" "devices")
QDEF(MP_QSTR_dict, (const byte*)"\x3f\x04" "dict")
QDEF(MP_QSTR_dict_view, (const byte*)"\x2d\x09" "dict_view")
QDEF(MP_QSTR_diff, (const byte*)"\xc8\x04" "diff")
QDEF(MP_QSTR_difference, (const byte*)"\x72\x0a" "difference")
QDEF(MP_QSTR_difference_update, (const byte*)"\x9c\x11" "difference_update")
QDEF(MP_QSTR_digitalio, (const byte*)"\x19\x09" "digitalio")
QDEF(MP_QSTR_dir, (const byte*)"\xfa\x03" "dir")
QDEF(MP_QSTR_direction, (const byte*)"\x20\x09" "direction")
QDEF(MP_QSTR_disable, (const byte*)"\x91\x07" "disable")
QDEF(MP_QSTR_disable_autoreload, (const byte*)"\xb0\x12" "disable_autoreload")
QDEF(MP_QSTR_disable_concurrent_write_protection, (const byte*)"\x3b\x23" "disable_concurrent_write_protection")
QDEF(MP_QSTR_disable_interrupts, (const byte*)"\xfa\x12" "disable_interrupts")
QDEF(MP_QSTR_discard, (const byte*)"\x0f\x07" "discard")
QDEF(MP_QSTR_divmod, (const byte*)"\xb8\x06" "divmod")
QDEF(MP_QSTR_doc, (const byte*)"\x2d\x03" "doc")
QDEF(MP_QSTR_dot, (const byte*)"\x3a\x03" "dot")
QDEF(MP_QSTR_drive_mode, (const byte*)"\x15\x0a" "drive_mode")
QDEF(MP_QSTR_dtype, (const byte*)"\x59\x05" "dtype")
QDEF(MP_QSTR_dump, (const byte*)"\xe9\x04" "dump")
QDEF(MP_QSTR_dumps, (const byte*)"\x7a\x05" "dumps")
QDEF(MP_QSTR_duty_cycle, (const byte*)"\xf6\x0a" "duty_cycle")
QDEF(MP_QSTR_e, (const byte*)"\xc0\x01" "e")
QDEF(MP_QSTR_eig, (const byte*)"\xae\x03" "eig")
QDEF(MP_QSTR_enable, (const byte*)"\x04\x06" "enable")
QDEF(MP_QSTR_enable_autoreload, (const byte*)"\x85\x11" "enable_autoreload")
QDEF(MP_QSTR_enable_interrupts, (const byte*)"\x4f\x11" "enable_interrupts")
QDEF(MP_QSTR_encode, (const byte*)"\x43\x06" "encode")
QDEF(MP_QSTR_encoding, (const byte*)"\x06\x08" "encoding")
QDEF(MP_QSTR_end, (const byte*)"\x0a\x03" "end")
QDEF(MP_QSTR_endpoint, (const byte*)"\x06\x08" "endpoint")
QDEF(MP_QSTR_endswith, (const byte*)"\x1b\x08" "endswith")
QDEF(MP_QSTR_enumerate, (const byte*)"\x71\x09" "enumerate")
QDEF(MP_QSTR_erase_filesystem, (const byte*)"\x79\x10" "erase_filesystem")
QDEF(MP_QSTR_erf, (const byte*)"\x94\x03" "erf")
QDEF(MP_QSTR_erfc, (const byte*)"\x77\x04" "erfc")
QDEF(MP_QSTR_errno, (const byte*)"\xc1\x05" "errno")
QDEF(MP_QSTR_eval, (const byte*)"\x9b\x04" "eval")
QDEF(MP_QSTR_exec, (const byte*)"\x1e\x04" "exec")
QDEF(MP_QSTR_exit, (const byte*)"\x85\x04" "exit")
QDEF(MP_QSTR_exp, (const byte*)"\xc8\x03" "exp")
QDEF(MP_QSTR_expm1, (const byte*)"\x74\x05" "expm1")
QDEF(MP_QSTR_extend, (const byte*)"\x63\x06" "extend")
QDEF(MP_QSTR_extras, (const byte*)"\x0c\x06" "extras")
QDEF(MP_QSTR_eye, (const byte*)"\xbc\x03" "eye")
QDEF(MP_QSTR_fabs, (const byte*)"\x93\x04" "fabs")
QDEF(MP_QSTR_fft, (const byte*)"\x91\x03" "fft")
QDEF(MP_QSTR_file, (const byte*)"\xc3\x04" "file")
QDEF(MP_QSTR_filename, (const byte*)"\xe4\x08" "filename")
QDEF(MP_QSTR_filename2, (const byte*)"\x56\x09" "filename2")
QDEF(MP_QSTR_fill, (const byte*)"\xca\x04" "fill")
QDEF(MP_QSTR_filter, (const byte*)"\x25\x06" "filter")
QDEF(MP_QSTR_find, (const byte*)"\x01\x04" "find")
QDEF(MP_QSTR_flatten, (const byte*)"\x25\x07" "flatten")
QDEF(MP_QSTR_flip, (const byte*)"\x76\x04" "flip")
QDEF(MP_QSTR_float, (const byte*)"\x35\x05" "float")
QDEF(MP_QSTR_floor, (const byte*)"\x7d\x05" "floor")
QDEF(MP_QSTR_flush, (const byte*)"\x61\x05" "flush")
QDEF(MP_QSTR_fmod, (const byte*)"\xe5\x04" "fmod")
QDEF(MP_QSTR_format, (const byte*)"\x26\x06" "format")
QDEF(MP_QSTR_frequency, (const byte*)"\xa1\x09" "frequency")
QDEF(MP_QSTR_frexp, (const byte*)"\x1c\x05" "frexp")
QDEF(MP_QSTR_from_bytes, (const byte*)"\x35\x0a" "from_bytes")
QDEF(MP_QSTR_fromkeys, (const byte*)"\x37\x08" "fromkeys")
QDEF(MP_QSTR_frozenset, (const byte*)"\xed\x09" "frozenset")
QDEF(MP_QSTR_function, (const byte*)"\x27\x08" "function")
QDEF(MP_QSTR_gamepad, (const byte*)"\x3e\x07" "gamepad")
QDEF(MP_QSTR_gamma, (const byte*)"\x02\x05" "gamma")
QDEF(MP_QSTR_gc, (const byte*)"\x61\x02" "gc")
QDEF(MP_QSTR_generator, (const byte*)"\x96\x09" "generator")
QDEF(MP_QSTR_get, (const byte*)"\x33\x03" "get")
QDEF(MP_QSTR_get_pressed, (const byte*)"\xea\x0b" "get_pressed")
QDEF(MP_QSTR_getattr, (const byte*)"\xc0\x07" "getattr")
QDEF(MP_QSTR_getcwd, (const byte*)"\x03\x06" "getcwd")
QDEF(MP_QSTR_getmount, (const byte*)"\xde\x08" "getmount")
QDEF(MP_QSTR_getrandbits, (const byte*)"\x66\x0b" "getrandbits")
QDEF(MP_QSTR_getter, (const byte*)"\x90\x06" "getter")
QDEF(MP_QSTR_getvalue, (const byte*)"\x78\x08" "getvalue")
QDEF(MP_QSTR_globals, (const byte*)"\x9d\x07" "globals")
QDEF(MP_QSTR_group, (const byte*)"\xba\x05" "group")
QDEF(MP_QSTR_groups, (const byte*)"\x89\x06" "groups")
QDEF(MP_QSTR_hasattr, (const byte*)"\x8c\x07" "hasattr")
QDEF(MP_QSTR_hash, (const byte*)"\xb7\x04" "hash")
QDEF(MP_QSTR_header, (const byte*)"\x9a\x06" "header")
QDEF(MP_QSTR_heap_lock, (const byte*)"\xad\x09" "heap_lock")
QDEF(MP_QSTR_heap_unlock, (const byte*)"\x56\x0b" "heap_unlock")
QDEF(MP_QSTR_help, (const byte*)"\x94\x04" "help")
QDEF(MP_QSTR_hex, (const byte*)"\x70\x03" "hex")
QDEF(MP_QSTR_id, (const byte*)"\x28\x02" "id")
QDEF(MP_QSTR_idle_state, (const byte*)"\x29\x0a" "idle_state")
QDEF(MP_QSTR_ifft, (const byte*)"\xf8\x04" "ifft")
QDEF(MP_QSTR_ilistdir, (const byte*)"\x71\x08" "ilistdir")
QDEF(MP_QSTR_imag, (const byte*)"\x47\x04" "imag")
QDEF(MP_QSTR_implementation, (const byte*)"\x17\x0e" "implementation")
QDEF(MP_QSTR_in_buffer, (const byte*)"\x1d\x09" "in_buffer")
QDEF(MP_QSTR_in_end, (const byte*)"\xf2\x06" "in_end")
QDEF(MP_QSTR_in_start, (const byte*)"\x7d\x08" "in_start")
QDEF(MP_QSTR_in_waiting, (const byte*)"\xd6\x0a" "in_waiting")
QDEF(MP_QSTR_index, (const byte*)"\x7b\x05" "index")
QDEF(MP_QSTR_indices, (const byte*)"\x5a\x07" "indices")
QDEF(MP_QSTR_input, (const byte*)"\x73\x05" "input")
QDEF(MP_QSTR_insert, (const byte*)"\x12\x06" "insert")
QDEF(MP_QSTR_int, (const byte*)"\x16\x03" "int")
QDEF(MP_QSTR_int16, (const byte*)"\xf1\x05" "int16")
QDEF(MP_QSTR_int8, (const byte*)"\xee\x04" "int8")
QDEF(MP_QSTR_intersection, (const byte*)"\x28\x0c" "intersection")
QDEF(MP_QSTR_intersection_update, (const byte*)"\x06\x13" "intersection_update")
QDEF(MP_QSTR_inv, (const byte*)"\x14\x03" "inv")
QDEF(MP_QSTR_io, (const byte*)"\x23\x02" "io")
QDEF(MP_QSTR_ioctl, (const byte*)"\x78\x05" "ioctl")
QDEF(MP_QSTR_isalpha, (const byte*)"\xeb\x07" "isalpha")
QDEF(MP_QSTR_isdigit, (const byte*)"\xa8\x07" "isdigit")
QDEF(MP_QSTR_isdisjoint, (const byte*)"\xf7\x0a" "isdisjoint")
QDEF(MP_QSTR_isenabled, (const byte*)"\x9a\x09" "isenabled")
QDEF(MP_QSTR_isfinite, (const byte*)"\xa6\x08" "isfinite")
QDEF(MP_QSTR_isinf, (const byte*)"\x3e\x05" "isinf")
QDEF(MP_QSTR_isinstance, (const byte*)"\xb6\x0a" "isinstance")
QDEF(MP_QSTR_islower, (const byte*)"\xfc\x07" "islower")
QDEF(MP_QSTR_isnan, (const byte*)"\x9e\x05" "isnan")
QDEF(MP_QSTR_isspace, (const byte*)"\x5b\x07" "isspace")
QDEF(MP_QSTR_issubclass, (const byte*)"\xb5\x0a" "issubclass")
QDEF(MP_QSTR_issubset, (const byte*)"\xb9\x08" "issubset")
QDEF(MP_QSTR_issuperset, (const byte*)"\xfc\x0a" "issuperset")
QDEF(MP_QSTR_isupper, (const byte*)"\xdd\x07" "isupper")
QDEF(MP_QSTR_items, (const byte*)"\xe3\x05" "items")
QDEF(MP_QSTR_itemsize, (const byte*)"\x75\x08" "itemsize")
QDEF(MP_QSTR_iter, (const byte*)"\x8f\x04" "iter")
QDEF(MP_QSTR_iterable, (const byte*)"\x25\x08" "iterable")
QDEF(MP_QSTR_iterator, (const byte*)"\x47\x08" "iterator")
QDEF(MP_QSTR_join, (const byte*)"\xa7\x04" "join")
QDEF(MP_QSTR_json, (const byte*)"\xfd\x04" "json")
QDEF(MP_QSTR_k, (const byte*)"\xce\x01" "k")
QDEF(MP_QSTR_kbd_intr, (const byte*)"\xf6\x08" "kbd_intr")
QDEF(MP_QSTR_keepends, (const byte*)"\x62\x08" "keepends")
QDEF(MP_QSTR_key, (const byte*)"\x32\x03" "key")
QDEF(MP_QSTR_keys, (const byte*)"\x01\x04" "keys")
QDEF(MP_QSTR_label, (const byte*)"\x43\x05" "label")
QDEF(MP_QSTR_ldexp, (const byte*)"\x40\x05" "ldexp")
QDEF(MP_QSTR_len, (const byte*)"\x62\x03" "len")
QDEF(MP_QSTR_length, (const byte*)"\x59\x06" "length")
QDEF(MP_QSTR_lgamma, (const byte*)"\xce\x06" "lgamma")
QDEF(MP_QSTR_linalg, (const byte*)"\x44\x06" "linalg")
QDEF(MP_QSTR_linspace, (const byte*)"\x6a\x08" "linspace")
QDEF(MP_QSTR_list, (const byte*)"\x27\x04" "list")
QDEF(MP_QSTR_listdir, (const byte*)"\x98\x07" "listdir")
QDEF(MP_QSTR_little, (const byte*)"\x89\x06" "little")
QDEF(MP_QSTR_load, (const byte*)"\x63\x04" "load")
QDEF(MP_QSTR_loads, (const byte*)"\xb0\x05" "loads")
QDEF(MP_QSTR_locals, (const byte*)"\x3b\x06" "locals")
QDEF(MP_QSTR_localtime, (const byte*)"\x7d\x09" "localtime")
QDEF(MP_QSTR_log, (const byte*)"\x21\x03" "log")
QDEF(MP_QSTR_log10, (const byte*)"\x40\x05" "log10")
QDEF(MP_QSTR_log2, (const byte*)"\x73\x04" "log2")
QDEF(MP_QSTR_lower, (const byte*)"\xc6\x05" "lower")
QDEF(MP_QSTR_lstrip, (const byte*)"\xe5\x06" "lstrip")
QDEF(MP_QSTR_machine, (const byte*)"\x60\x07" "machine")
QDEF(MP_QSTR_map, (const byte*)"\xb9\x03" "map")
QDEF(MP_QSTR_match, (const byte*)"\x96\x05" "match")
QDEF(MP_QSTR_math, (const byte*)"\x35\x04" "math")
QDEF(MP_QSTR_max, (const byte*)"\xb1\x03" "max")
QDEF(MP_QSTR_maximum, (const byte*)"\x6d\x07" "maximum")
QDEF(MP_QSTR_maxlen, (const byte*)"\x56\x06" "maxlen")
QDEF(MP_QSTR_maxsize, (const byte*)"\xd4\x07" "maxsize")
QDEF(MP_QSTR_mean, (const byte*)"\xc2\x04" "mean")
QDEF(MP_QSTR_mem_alloc, (const byte*)"\x52\x09" "mem_alloc")
QDEF(MP_QSTR_mem_free, (const byte*)"\xcb\x08" "mem_free")
QDEF(MP_QSTR_memoryview, (const byte*)"\x69\x0a" "memoryview")
QDEF(MP_QSTR_microcontroller, (const byte*)"\xa3\x0f" "microcontroller")
QDEF(MP_QSTR_micropython, (const byte*)"\x0b\x0b" "micropython")
QDEF(MP_QSTR_min, (const byte*)"\xaf\x03" "min")
QDEF(MP_QSTR_minimum, (const byte*)"\x73\x07" "minimum")
QDEF(MP_QSTR_mkdir, (const byte*)"\x9c\x05" "mkdir")
QDEF(MP_QSTR_mkfs, (const byte*)"\x76\x04" "mkfs")
QDEF(MP_QSTR_mktime, (const byte*)"\x96\x06" "mktime")
QDEF(MP_QSTR_mode, (const byte*)"\x26\x04" "mode")
QDEF(MP_QSTR_modf, (const byte*)"\x25\x04" "modf")
QDEF(MP_QSTR_module, (const byte*)"\xbf\x06" "module")
QDEF(MP_QSTR_modules, (const byte*)"\xec\x07" "modules")
QDEF(MP_QSTR_monotonic, (const byte*)"\x19\x09" "monotonic")
QDEF(MP_QSTR_monotonic_ns, (const byte*)"\x3b\x0c" "monotonic_ns")
QDEF(MP_QSTR_mount, (const byte*)"\xa8\x05" "mount")
QDEF(MP_QSTR_n, (const byte*)"\xcb\x01" "n")
QDEF(MP_QSTR_name, (const byte*)"\xa2\x04" "name")
QDEF(MP_QSTR_namedtuple, (const byte*)"\x1e\x0a" "namedtuple")
QDEF(MP_QSTR_native, (const byte*)"\x84\x06" "native")
QDEF(MP_QSTR_ndarray, (const byte*)"\x76\x07" "ndarray")
QDEF(MP_QSTR_next, (const byte*)"\x42\x04" "next")
QDEF(MP_QSTR_nodename, (const byte*)"\x62\x08" "nodename")
QDEF(MP_QSTR_num, (const byte*)"\x73\x03" "num")
QDEF(MP_QSTR_numerical, (const byte*)"\xc3\x09" "numerical")
QDEF(MP_QSTR_nvm, (const byte*)"\x90\x03" "nvm")
QDEF(MP_QSTR_object, (const byte*)"\x90\x06" "object")
QDEF(MP_QSTR_oct, (const byte*)"\xfd\x03" "oct")
QDEF(MP_QSTR_offset, (const byte*)"\x48\x06" "offset")
QDEF(MP_QSTR_on_next_reset, (const byte*)"\xb6\x0d" "on_next_reset")
QDEF(MP_QSTR_ones, (const byte*)"\xd2\x04" "ones")
QDEF(MP_QSTR_open, (const byte*)"\xd1\x04" "open")
QDEF(MP_QSTR_opt_level, (const byte*)"\x87\x09" "opt_level")
QDEF(MP_QSTR_ord, (const byte*)"\x1c\x03" "ord")
QDEF(MP_QSTR_order, (const byte*)"\x6b\x05" "order")
QDEF(MP_QSTR_os, (const byte*)"\x79\x02" "os")
QDEF(MP_QSTR_out_buffer, (const byte*)"\xf4\x0a" "out_buffer")
QDEF(MP_QSTR_out_end, (const byte*)"\x7b\x07" "out_end")
QDEF(MP_QSTR_out_start, (const byte*)"\xf4\x09" "out_start")
QDEF(MP_QSTR_pack, (const byte*)"\xbc\x04" "pack")
QDEF(MP_QSTR_pack_into, (const byte*)"\x1f\x09" "pack_into")
QDEF(MP_QSTR_parity, (const byte*)"\x42\x06" "parity")
QDEF(MP_QSTR_partition, (const byte*)"\x87\x09" "partition")
QDEF(MP_QSTR_path, (const byte*)"\x88\x04" "path")
QDEF(MP_QSTR_pause, (const byte*)"\xd7\x05" "pause")
QDEF(MP_QSTR_paused, (const byte*)"\xd3\x06" "paused")
QDEF(MP_QSTR_pend_throw, (const byte*)"\xf3\x0a" "pend_throw")
QDEF(MP_QSTR_phase, (const byte*)"\x6a\x05" "phase")
QDEF(MP_QSTR_pi, (const byte*)"\x1c\x02" "pi")
QDEF(MP_QSTR_pin, (const byte*)"\xf2\x03" "pin")
QDEF(MP_QSTR_polarity, (const byte*)"\x41\x08" "polarity")
QDEF(MP_QSTR_poly, (const byte*)"\x8f\x04" "poly")
QDEF(MP_QSTR_polyfit, (const byte*)"\x34\x07" "polyfit")
QDEF(MP_QSTR_polyval, (const byte*)"\x34\x07" "polyval")
QDEF(MP_QSTR_pop, (const byte*)"\x2a\x03" "pop")
QDEF(MP_QSTR_popitem, (const byte*)"\xbf\x07" "popitem")
QDEF(MP_QSTR_popleft, (const byte*)"\x71\x07" "popleft")
QDEF(MP_QSTR_ports, (const byte*)"\xaf\x05" "ports")
QDEF(MP_QSTR_pow, (const byte*)"\x2d\x03" "pow")
QDEF(MP_QSTR_print, (const byte*)"\x54\x05" "print")
QDEF(MP_QSTR_print_exception, (const byte*)"\x1c\x0f" "print_exception")
QDEF(MP_QSTR_property, (const byte*)"\xc2\x08" "property")
QDEF(MP_QSTR_protocol_pin, (const byte*)"\x1b\x0c" "protocol_pin")
QDEF(MP_QSTR_protocol_stream, (const byte*)"\x90\x0f" "protocol_stream")
QDEF(MP_QSTR_protocol_vfs, (const byte*)"\xef\x0c" "protocol_vfs")
QDEF(MP_QSTR_pull, (const byte*)"\x80\x04" "pull")
QDEF(MP_QSTR_pulseio, (const byte*)"\xfc\x07" "pulseio")
QDEF(MP_QSTR_r, (const byte*)"\xd7\x01" "r")
QDEF(MP_QSTR_radians, (const byte*)"\x87\x07" "radians")
QDEF(MP_QSTR_randint, (const byte*)"\xaf\x07" "randint")
QDEF(MP_QSTR_random, (const byte*)"\xbe\x06" "random")
QDEF(MP_QSTR_randrange, (const byte*)"\xa3\x09" "randrange")
QDEF(MP_QSTR_range, (const byte*)"\x1a\x05" "range")
QDEF(MP_QSTR_raw_value, (const byte*)"\xf5\x09" "raw_value")
QDEF(MP_QSTR_re, (const byte*)"\xd2\x02" "re")
QDEF(MP_QSTR_read, (const byte*)"\xb7\x04" "read")
QDEF(MP_QSTR_read_bit, (const byte*)"\x97\x08" "read_bit")
QDEF(MP_QSTR_readblocks, (const byte*)"\x2d\x0a" "readblocks")
QDEF(MP_QSTR_readfrom_into, (const byte*)"\x82\x0d" "readfrom_into")
QDEF(MP_QSTR_readinto, (const byte*)"\x4b\x08" "readinto")
QDEF(MP_QSTR_readline, (const byte*)"\xf9\x08" "readline")
QDEF(MP_QSTR_readlines, (const byte*)"\x6a\x09" "readlines")
QDEF(MP_QSTR_readonly, (const byte*)"\x03\x08" "readonly")
QDEF(MP_QSTR_real, (const byte*)"\xbf\x04" "real")
QDEF(MP_QSTR_receiver_buffer_size, (const byte*)"\x99\x14" "receiver_buffer_size")
QDEF(MP_QSTR_reference_voltage, (const byte*)"\x93\x11" "reference_voltage")
QDEF(MP_QSTR_release, (const byte*)"\xec\x07" "release")
QDEF(MP_QSTR_reload, (const byte*)"\x74\x06" "reload")
QDEF(MP_QSTR_remount, (const byte*)"\x9f\x07" "remount")
QDEF(MP_QSTR_remove, (const byte*)"\x63\x06" "remove")
QDEF(MP_QSTR_rename, (const byte*)"\x35\x06" "rename")
QDEF(MP_QSTR_replace, (const byte*)"\x49\x07" "replace")
QDEF(MP_QSTR_repr, (const byte*)"\xd0\x04" "repr")
QDEF(MP_QSTR_reset, (const byte*)"\x10\x05" "reset")
QDEF(MP_QSTR_reset_input_buffer, (const byte*)"\xe6\x12" "reset_input_buffer")
QDEF(MP_QSTR_reshape, (const byte*)"\x7d\x07" "reshape")
QDEF(MP_QSTR_resume, (const byte*)"\x5c\x06" "resume")
QDEF(MP_QSTR_retstep, (const byte*)"\x34\x07" "retstep")
QDEF(MP_QSTR_reverse, (const byte*)"\x25\x07" "reverse")
QDEF(MP_QSTR_reversed, (const byte*)"\xa1\x08" "reversed")
QDEF(MP_QSTR_rfind, (const byte*)"\xd2\x05" "rfind")
QDEF(MP_QSTR_rindex, (const byte*)"\xe9\x06" "rindex")
QDEF(MP_QSTR_rmdir, (const byte*)"\x45\x05" "rmdir")
QDEF(MP_QSTR_roll, (const byte*)"\x58\x04" "roll")
QDEF(MP_QSTR_round, (const byte*)"\xe7\x05" "round")
QDEF(MP_QSTR_rpartition, (const byte*)"\x15\x0a" "rpartition")
QDEF(MP_QSTR_rs485_dir, (const byte*)"\xdd\x09" "rs485_dir")
QDEF(MP_QSTR_rs485_invert, (const byte*)"\xb0\x0c" "rs485_invert")
QDEF(MP_QSTR_rsplit, (const byte*)"\xa5\x06" "rsplit")
QDEF(MP_QSTR_rstrip, (const byte*)"\x3b\x06" "rstrip")
QDEF(MP_QSTR_rts, (const byte*)"\x50\x03" "rts")
QDEF(MP_QSTR_runtime, (const byte*)"\x99\x07" "runtime")
QDEF(MP_QSTR_rx, (const byte*)"\xcf\x02" "rx")
QDEF(MP_QSTR_scan, (const byte*)"\x1a\x04" "scan")
QDEF(MP_QSTR_scl, (const byte*)"\xf9\x03" "scl")
QDEF(MP_QSTR_sda, (const byte*)"\x53\x03" "sda")
QDEF(MP_QSTR_search, (const byte*)"\xab\x06" "search")
QDEF(MP_QSTR_seed, (const byte*)"\x92\x04" "seed")
QDEF(MP_QSTR_seek, (const byte*)"\x9d\x04" "seek")
QDEF(MP_QSTR_send, (const byte*)"\xb9\x04" "send")
QDEF(MP_QSTR_send_report, (const byte*)"\x08\x0b" "send_report")
QDEF(MP_QSTR_sep, (const byte*)"\x23\x03" "sep")
QDEF(MP_QSTR_serial_bytes_available, (const byte*)"\x45\x16" "serial_bytes_available")
QDEF(MP_QSTR_serial_connected, (const byte*)"\xa5\x10" "serial_connected")
QDEF(MP_QSTR_set, (const byte*)"\x27\x03" "set")
QDEF(MP_QSTR_set_next_stack_limit, (const byte*)"\xa4\x14" "set_next_stack_limit")
QDEF(MP_QSTR_set_rgb_status_brightness, (const byte*)"\x92\x19" "set_rgb_status_brightness")
QDEF(MP_QSTR_setattr, (const byte*)"\xd4\x07" "setattr")
QDEF(MP_QSTR_setdefault, (const byte*)"\x6c\x0a" "setdefault")
QDEF(MP_QSTR_setter, (const byte*)"\x04\x06" "setter")
QDEF(MP_QSTR_shape, (const byte*)"\xca\x05" "shape")
QDEF(MP_QSTR_show, (const byte*)"\x86\x04" "show")
QDEF(MP_QSTR_signed, (const byte*)"\x37\x06" "signed")
QDEF(MP_QSTR_sin, (const byte*)"\xb1\x03" "sin")
QDEF(MP_QSTR_sinh, (const byte*)"\xb9\x04" "sinh")
QDEF(MP_QSTR_size, (const byte*)"\x20\x04" "size")
QDEF(MP_QSTR_sleep, (const byte*)"\xea\x05" "sleep")
QDEF(MP_QSTR_slice, (const byte*)"\xb5\x05" "slice")
QDEF(MP_QSTR_sort, (const byte*)"\xbf\x04" "sort")
QDEF(MP_QSTR_sorted, (const byte*)"\x5e\x06" "sorted")
QDEF(MP_QSTR_span, (const byte*)"\xc9\x04" "span")
QDEF(MP_QSTR_spectrogram, (const byte*)"\x30\x0b" "spectrogram")
QDEF(MP_QSTR_split, (const byte*)"\xb7\x05" "split")
QDEF(MP_QSTR_splitlines, (const byte*)"\x6a\x0a" "splitlines")
QDEF(MP_QSTR_sqrt, (const byte*)"\x21\x04" "sqrt")
QDEF(MP_QSTR_start, (const byte*)"\x85\x05" "start")
QDEF(MP_QSTR_startswith, (const byte*)"\x74\x0a" "startswith")
QDEF(MP_QSTR_stat, (const byte*)"\xd7\x04" "stat")
QDEF(MP_QSTR_staticmethod, (const byte*)"\x62\x0c" "staticmethod")
QDEF(MP_QSTR_statvfs, (const byte*)"\x14\x07" "statvfs")
QDEF(MP_QSTR_std, (const byte*)"\x46\x03" "std")
QDEF(MP_QSTR_stderr, (const byte*)"\xa3\x06" "stderr")
QDEF(MP_QSTR_stdin, (const byte*)"\x21\x05" "stdin")
QDEF(MP_QSTR_stdout, (const byte*)"\x08\x06" "stdout")
QDEF(MP_QSTR_step, (const byte*)"\x57\x04" "step")
QDEF(MP_QSTR_stop, (const byte*)"\x9d\x04" "stop")
QDEF(MP_QSTR_storage, (const byte*)"\xbc\x07" "storage")
QDEF(MP_QSTR_str, (const byte*)"\x50\x03" "str")
QDEF(MP_QSTR_strerror, (const byte*)"\x48\x08" "strerror")
QDEF(MP_QSTR_strip, (const byte*)"\x29\x05" "strip")
QDEF(MP_QSTR_struct, (const byte*)"\x12\x06" "struct")
QDEF(MP_QSTR_struct_time, (const byte*)"\xf8\x0b" "struct_time")
QDEF(MP_QSTR_sub, (const byte*)"\x21\x03" "sub")
QDEF(MP_QSTR_sum, (const byte*)"\x2e\x03" "sum")
QDEF(MP_QSTR_super, (const byte*)"\xc4\x05" "super")
QDEF(MP_QSTR_supervisor, (const byte*)"\x35\x0a" "supervisor")
QDEF(MP_QSTR_switch_to_input, (const byte*)"\xfa\x0f" "switch_to_input")
QDEF(MP_QSTR_switch_to_output, (const byte*)"\xf3\x10" "switch_to_output")
QDEF(MP_QSTR_symmetric_difference, (const byte*)"\xce\x14" "symmetric_difference")
QDEF(MP_QSTR_symmetric_difference_update, (const byte*)"\x60\x1b" "symmetric_difference_update")
QDEF(MP_QSTR_sync, (const byte*)"\xa2\x04" "sync")
QDEF(MP_QSTR_sys, (const byte*)"\xbc\x03" "sys")
QDEF(MP_QSTR_sysname, (const byte*)"\x9b\x07" "sysname")
QDEF(MP_QSTR_tan, (const byte*)"\xfe\x03" "tan")
QDEF(MP_QSTR_tanh, (const byte*)"\xd6\x04" "tanh")
QDEF(MP_QSTR_tell, (const byte*)"\x14\x04" "tell")
QDEF(MP_QSTR_temperature, (const byte*)"\xe9\x0b" "temperature")
QDEF(MP_QSTR_threshold, (const byte*)"\xf2\x09" "threshold")
QDEF(MP_QSTR_throw, (const byte*)"\xb3\x05" "throw")
QDEF(MP_QSTR_time, (const byte*)"\xf0\x04" "time")
QDEF(MP_QSTR_timeout, (const byte*)"\x3e\x07" "timeout")
QDEF(MP_QSTR_tm_hour, (const byte*)"\xa3\x07" "tm_hour")
QDEF(MP_QSTR_tm_isdst, (const byte*)"\xda\x08" "tm_isdst")
QDEF(MP_QSTR_tm_mday, (const byte*)"\xd2\x07" "tm_mday")
QDEF(MP_QSTR_tm_min, (const byte*)"\xa9\x06" "tm_min")
QDEF(MP_QSTR_tm_mon, (const byte*)"\x6f\x06" "tm_mon")
QDEF(MP_QSTR_tm_sec, (const byte*)"\x36\x06" "tm_sec")
QDEF(MP_QSTR_tm_wday, (const byte*)"\x08\x07" "tm_wday")
QDEF(MP_QSTR_tm_yday, (const byte*)"\x46\x07" "tm_yday")
QDEF(MP_QSTR_tm_year, (const byte*)"\x8c\x07" "tm_year")
QDEF(MP_QSTR_to_bytes, (const byte*)"\xd8\x08" "to_bytes")
QDEF(MP_QSTR_touchio, (const byte*)"\x66\x07" "touchio")
QDEF(MP_QSTR_trace, (const byte*)"\xa4\x05" "trace")
QDEF(MP_QSTR_trailer, (const byte*)"\x10\x07" "trailer")
QDEF(MP_QSTR_transpose, (const byte*)"\xf6\x09" "transpose")
QDEF(MP_QSTR_trigger_duration, (const byte*)"\x1c\x10" "trigger_duration")
QDEF(MP_QSTR_trunc, (const byte*)"\x5b\x05" "trunc")
QDEF(MP_QSTR_try_lock, (const byte*)"\x2e\x08" "try_lock")
QDEF(MP_QSTR_tuple, (const byte*)"\xfd\x05" "tuple")
QDEF(MP_QSTR_tx, (const byte*)"\x89\x02" "tx")
QDEF(MP_QSTR_type, (const byte*)"\x9d\x04" "type")
QDEF(MP_QSTR_uid, (const byte*)"\xbd\x03" "uid")
QDEF(MP_QSTR_uint16, (const byte*)"\x84\x06" "uint16")
QDEF(MP_QSTR_uint8, (const byte*)"\x7b\x05" "uint8")
QDEF(MP_QSTR_uio, (const byte*)"\xb6\x03" "uio")
QDEF(MP_QSTR_ulab, (const byte*)"\x9f\x04" "ulab")
QDEF(MP_QSTR_umount, (const byte*)"\xdd\x06" "umount")
QDEF(MP_QSTR_uname, (const byte*)"\xb7\x05" "uname")
QDEF(MP_QSTR_uniform, (const byte*)"\x01\x07" "uniform")
QDEF(MP_QSTR_union, (const byte*)"\xf6\x05" "union")
QDEF(MP_QSTR_unlink, (const byte*)"\xfe\x06" "unlink")
QDEF(MP_QSTR_unlock, (const byte*)"\x15\x06" "unlock")
QDEF(MP_QSTR_unpack, (const byte*)"\x07\x06" "unpack")
QDEF(MP_QSTR_unpack_from, (const byte*)"\x0e\x0b" "unpack_from")
QDEF(MP_QSTR_update, (const byte*)"\xb4\x06" "update")
QDEF(MP_QSTR_upper, (const byte*)"\x27\x05" "upper")
QDEF(MP_QSTR_urandom, (const byte*)"\xab\x07" "urandom")
QDEF(MP_QSTR_usage, (const byte*)"\x01\x05" "usage")
QDEF(MP_QSTR_usage_page, (const byte*)"\xec\x0a" "usage_page")
QDEF(MP_QSTR_usb_hid, (const byte*)"\xdb\x07" "usb_hid")
QDEF(MP_QSTR_usb_midi, (const byte*)"\xb7\x08" "usb_midi")
QDEF(MP_QSTR_v, (const byte*)"\xd3\x01" "v")
QDEF(MP_QSTR_value, (const byte*)"\x4e\x05" "value")
QDEF(MP_QSTR_values, (const byte*)"\x7d\x06" "values")
QDEF(MP_QSTR_variable_frequency, (const byte*)"\x58\x12" "variable_frequency")
QDEF(MP_QSTR_vector, (const byte*)"\xdc\x06" "vector")
QDEF(MP_QSTR_version, (const byte*)"\xbf\x07" "version")
QDEF(MP_QSTR_version_info, (const byte*)"\x6e\x0c" "version_info")
QDEF(MP_QSTR_voltage, (const byte*)"\x87\x07" "voltage")
QDEF(MP_QSTR_wheel, (const byte*)"\x76\x05" "wheel")
QDEF(MP_QSTR_write, (const byte*)"\x98\x05" "write")
QDEF(MP_QSTR_write_bit, (const byte*)"\xf8\x09" "write_bit")
QDEF(MP_QSTR_write_readinto, (const byte*)"\x89\x0e" "write_readinto")
QDEF(MP_QSTR_write_value, (const byte*)"\x4c\x0b" "write_value")
QDEF(MP_QSTR_writeblocks, (const byte*)"\x02\x0b" "writeblocks")
QDEF(MP_QSTR_writeto, (const byte*)"\x03\x07" "writeto")
QDEF(MP_QSTR_writeto_then_readfrom, (const byte*)"\x70\x15" "writeto_then_readfrom")
QDEF(MP_QSTR_zeros, (const byte*)"\x94\x05" "zeros")
QDEF(MP_QSTR_zip, (const byte*)"\xe6\x03" "zip")
TRANSLATION("function missing required keyword argument '%q'", 48, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xb1, 0xbb, 0x9a, 0x68, 0x0c, 0x5e, 0x78, 0x36, 0x2a, 0x07, 0x91, 0x6b, 0xe8, 0xad, 0x40, 0x16, 0xd3, 0x16, 0x24, 0x80, 0xd9, 0xcd, 0xe7, 0xb0 }) // function missing required keyword argument \'%q\'
TRANSLATION("can't convert %s to complex", 28, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0xe6, 0x70, 0x85, 0x09, 0xad, 0xaf, 0x52, 0xe4 }) // can\'t convert %s to complex
TRANSLATION("'%s' object cannot assign attribute '%q'", 41, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x26, 0x28, 0x8b, 0x00, 0x2e, 0xe7, 0xa2, 0x00, 0xc4, 0x31, 0xe5, 0x88, 0x20, 0xd9, 0xcd, 0xe7, 0xb0 }) // \'%s\' object cannot assign attribute \'%q\'
TRANSLATION("indices must be integers, slices, or Boolean lists", 51, { 0x34, 0xa1, 0xcc, 0x9c, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0xd2, 0x0b, 0x42, 0x67, 0xf7, 0x03, 0xd4, 0xe6, 0x4f, 0xee, 0x05, 0x60, 0xf9, 0xaa, 0xd4, 0x85, 0x02, 0xa6, 0xf0, 0xe0 }) // indices must be integers, slices, or Boolean lists
TRANSLATION("no active exception to reraise", 31, { 0x45, 0x01, 0x9c, 0x1f, 0x12, 0x02, 0xe5, 0x32, 0xbc, 0x1a, 0xa0, 0x42, 0x83, 0x13, 0x09, 0xb9, 0x00 }) // no active exception to reraise
TRANSLATION("name not defined", 17, { 0x41, 0xb1, 0x02, 0x2c, 0x05, 0x0b, 0x33, 0x42, 0xa0 }) // name not defined
TRANSLATION("slice step cannot be zero", 26, { 0x7a, 0x9c, 0xc8, 0x1e, 0x0a, 0xe1, 0x31, 0x44, 0x58, 0x0c, 0x88, 0x3f, 0x92, 0x65 }) // slice step cannot be zero
TRANSLATION("Missing MISO or MOSI Pin", 25, { 0xfb, 0x1b, 0xb9, 0xa6, 0x81, 0xf6, 0xec, 0xf0, 0xee, 0x05, 0x60, 0xfb, 0x77, 0x78, 0x76, 0x06, 0xf3, 0x40 }) // Missing MISO or MOSI Pin
TRANSLATION("matrix dimensions do not match", 31, { 0xb0, 0xc3, 0x1f, 0x20, 0xa1, 0xd8, 0x91, 0xcd, 0x51, 0xc2, 0x8a, 0x08, 0xb0, 0x16, 0x18, 0x9f, 0x00 }) // matrix dimensions do not match
TRANSLATION("Expected tuple of length %d, got %d", 36, { 0xdd, 0xca, 0xe5, 0x38, 0x2a, 0x04, 0x62, 0xf5, 0x20, 0x5c, 0xc2, 0xa4, 0x9a, 0x47, 0x00, 0xe6, 0xa7, 0xb8, 0x34, 0x58, 0x0e, 0x6a, 0x00 }) // Expected tuple of length %d, got %d
TRANSLATION("RTS/CTS/RS485 Not yet supported on this device", 47, { 0xef, 0xf1, 0xf0, 0xf8, 0x75, 0x78, 0xf8, 0x7c, 0x3b, 0xfc, 0x3f, 0x3f, 0xd7, 0xe4, 0x1d, 0xab, 0x01, 0xa9, 0x40, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x02, 0xa0, 0x47, 0x03, 0x70, 0xa1, 0x71, 0x39, 0x90 }) // RTS/CTS/RS485 Not yet supported on this device
TRANSLATION("%%c requires int or char", 25, { 0xe6, 0xe6, 0x98, 0x31, 0x79, 0xe0, 0xd8, 0x9c, 0x0d, 0x20, 0x15, 0x82, 0x7c, 0x05, 0x80 }) // %%c requires int or char
TRANSLATION("chr() arg not in range(0x110000)", 33, { 0x9f, 0x06, 0xf6, 0x7b, 0x40, 0x5b, 0x40, 0x45, 0x80, 0x34, 0x06, 0x14, 0xd0, 0xbd, 0x9b, 0x79, 0x74, 0x74, 0x6d, 0xdb, 0xb7, 0x6f, 0xb4 }) // chr() arg not in range(0x110000)
TRANSLATION("WARNING: Your code filename has two extensions\n", 49, { 0xfe, 0x3a, 0x7b, 0xfb, 0x7b, 0x3b, 0x7e, 0xbf, 0xb0, 0x7f, 0xda, 0xe1, 0x82, 0x6b, 0x42, 0x0c, 0xce, 0xa4, 0x83, 0x62, 0x0e, 0x02, 0xe1, 0x1e, 0x8a, 0x05, 0xca, 0x09, 0x1c, 0xd5, 0x1f, 0xd7, 0xea }) // WARNING: Your code filename has two extensions\r\n
TRANSLATION("Invalid run mode.", 18, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x36, 0x10, 0x2c, 0xb4, 0x2e, 0x70 }) // Invalid run mode.
TRANSLATION("Read-only filesystem", 21, { 0xef, 0x21, 0xa7, 0xbd, 0x52, 0xba, 0x86, 0x67, 0x52, 0x7d, 0x5e, 0x0a, 0xc0 }) // Read-only filesystem
TRANSLATION("Invalid I2C pin selection", 26, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x76, 0x7c, 0x7a, 0x82, 0xe6, 0x80, 0xe5, 0x52, 0x9c, 0x1a, 0xa0 }) // Invalid I2C pin selection
TRANSLATION("  File \"%q\", line %d", 21, { 0x00, 0xfa, 0x1d, 0x48, 0x3f, 0xf5, 0xcd, 0xe7, 0xff, 0xaf, 0x70, 0x54, 0xd0, 0x83, 0x9a, 0x80 }) //   File \"%q\", line %d
TRANSLATION("n must be between 0, and 9", 27, { 0x40, 0xb6, 0x1e, 0x03, 0x22, 0x0c, 0x8a, 0x3d, 0x08, 0x90, 0x36, 0xfb, 0x80, 0x52, 0x81, 0xfd, 0x80 }) // n must be between 0, and 9
TRANSLATION("Invalid DAC pin supplied", 25, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x75, 0xf4, 0xf5, 0x05, 0xcd, 0x01, 0xf1, 0x7b, 0xd4, 0xca, 0x80 }) // Invalid DAC pin supplied
TRANSLATION("Invalid word/bit length", 24, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x7a, 0x2b, 0x53, 0xe1, 0x91, 0xc0, 0x54, 0x93, 0x48, 0xe0 }) // Invalid word/bit length
TRANSLATION("threshold must be in the range 0-65536", 39, { 0x8e, 0x0c, 0x4f, 0xc1, 0x6b, 0x40, 0xb6, 0x1e, 0x03, 0x22, 0x03, 0x40, 0x8e, 0x04, 0x0c, 0x29, 0xa1, 0x06, 0xdf, 0x7f, 0xe9, 0xf2, 0xf9, 0x7e, 0x5f, 0xa0 }) // threshold must be in the range 0-65536
TRANSLATION("Frequency must match existing PWMOut using this timer", 54, { 0xfa, 0x31, 0x79, 0xe0, 0x92, 0x7a, 0x85, 0xb0, 0xf0, 0x16, 0x18, 0x9f, 0x00, 0x2e, 0x46, 0xf0, 0x69, 0xa0, 0x6f, 0xfe, 0x3e, 0xdd, 0xd8, 0x80, 0xc3, 0x9a, 0x68, 0x11, 0xc0, 0xdc, 0x20, 0xec, 0x4c }) // Frequency must match existing PWMOut using this timer
TRANSLATION("ddof must be smaller than length of data set", 45, { 0xa5, 0x17, 0x30, 0xb6, 0x1e, 0x03, 0x22, 0x07, 0xb0, 0xd6, 0xa4, 0xc1, 0x1c, 0x05, 0x02, 0xa4, 0x9a, 0x47, 0x00, 0x5c, 0xc2, 0x83, 0x02, 0x0e, 0x50 }) // ddof must be smaller than length of data set
TRANSLATION("single '}' encountered in format string", 40, { 0x73, 0x4d, 0x2a, 0x41, 0xb3, 0xff, 0xdb, 0x00, 0x92, 0x6b, 0x84, 0x82, 0x62, 0xa0, 0x1a, 0x06, 0x6a, 0xd6, 0x18, 0x07, 0x86, 0x34, 0xd0 }) // single \'}\' encountered in format string
TRANSLATION("indices must be integers", 25, { 0x34, 0xa1, 0xcc, 0x9c, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0xd2, 0x0b, 0x42, 0x67 }) // indices must be integers
TRANSLATION("sign not allowed in string format specifier", 44, { 0x73, 0xd1, 0x01, 0x16, 0x00, 0x6b, 0x55, 0xf4, 0x2a, 0x01, 0xa0, 0x3c, 0x31, 0xa6, 0x81, 0x9a, 0xb5, 0x86, 0x01, 0xee, 0x53, 0x3c, 0xcc, 0x98 }) // sign not allowed in string format specifier
TRANSLATION("object with buffer protocol required", 37, { 0x5c, 0xbf, 0x05, 0x38, 0x0f, 0x43, 0x8e, 0x01, 0x96, 0x33, 0xcc, 0x98, 0x2e, 0xcb, 0x0b, 0x35, 0xa8, 0x31, 0x79, 0xe0, 0xd8, 0xa8 }) // object with buffer protocol required
TRANSLATION("Invalid direction.", 19, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x50, 0xd8, 0xa7, 0x06, 0xa9, 0xce }) // Invalid direction.
TRANSLATION("Slices not supported", 21, { 0xf0, 0xa9, 0xcc, 0x9c, 0x11, 0x60, 0x1f, 0x17, 0xba, 0xb4, 0x15, 0x00 }) // Slices not supported
TRANSLATION("can't declare nonlocal in outer code", 37, { 0x98, 0xa6, 0xc8, 0x0a, 0x14, 0xea, 0x2c, 0x40, 0x8a, 0x95, 0x59, 0x8d, 0x40, 0xd0, 0x17, 0x10, 0x4c, 0x13, 0x5a, 0x10 }) // can\'t declare nonlocal in outer code
TRANSLATION("invalid syntax for integer with base %d", 40, { 0x34, 0xe2, 0x35, 0x3a, 0x03, 0xea, 0x90, 0x3c, 0x83, 0x35, 0x60, 0x34, 0x82, 0xd0, 0x98, 0x3d, 0x0e, 0x38, 0x06, 0x42, 0xe4, 0x1c, 0xd4 }) // invalid syntax for integer with base %d
TRANSLATION("end of format while looking for conversion specifier", 53, { 0x24, 0xa0, 0x2e, 0x61, 0x9a, 0xb5, 0x86, 0x03, 0xd3, 0x81, 0xd4, 0x82, 0xaa, 0xbe, 0x46, 0x9a, 0x06, 0x6a, 0xc1, 0x35, 0x4e, 0x24, 0xce, 0x6a, 0x80, 0xf7, 0x29, 0x9e, 0x66, 0x4c }) // end of format while looking for conversion specifier
TRANSLATION("bits must be 7, 8 or 9", 23, { 0xc8, 0xe1, 0xc2, 0xd8, 0x78, 0x0c, 0x88, 0x3f, 0xaf, 0xb8, 0x3f, 0x50, 0x56, 0x0f, 0xec }) // bits must be 7, 8 or 9
TRANSLATION("Attempted heap allocation when MicroPython VM not running.", 59, { 0xe9, 0x88, 0x2b, 0x5e, 0x0a, 0x81, 0xc0, 0x86, 0xe0, 0x35, 0xaa, 0xcc, 0x60, 0xd5, 0x03, 0xd3, 0x81, 0x20, 0x7d, 0x8e, 0x6c, 0xbb, 0xf5, 0x8e, 0x0a, 0x81, 0xfe, 0xbe, 0xc0, 0x8b, 0x00, 0xd8, 0x44, 0x34, 0xd3, 0x9c }) // Attempted heap allocation when MicroPython VM not running.
TRANSLATION("function does not take keyword arguments", 41, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xa2, 0x93, 0x82, 0x2c, 0x04, 0x0f, 0x91, 0x07, 0x91, 0x6b, 0xe8, 0xad, 0x40, 0x16, 0xd3, 0x16, 0x24, 0x87 }) // function does not take keyword arguments
TRANSLATION("iterables are not of the same length", 37, { 0x38, 0x26, 0x1c, 0xaa, 0x4e, 0x02, 0xc4, 0x08, 0xb0, 0x0b, 0x98, 0x47, 0x02, 0x07, 0x1b, 0x10, 0x54, 0x93, 0x48, 0xe0 }) // iterables are not of the same length
TRANSLATION("'%s' object is not iterable", 28, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x0d, 0xc1, 0x16, 0x00, 0xe0, 0x98, 0x72, 0xa9, 0x00 }) // \'%s\' object is not iterable
TRANSLATION("extra keyword arguments given", 30, { 0x2e, 0x50, 0xc2, 0x1e, 0x45, 0xaf, 0xa2, 0xb5, 0x00, 0x5b, 0x4c, 0x58, 0x92, 0x1c, 0x34, 0x3e, 0x24, 0x80 }) // extra keyword arguments given
TRANSLATION("Failed to write internal flash.", 32, { 0xfa, 0x09, 0xd4, 0xa8, 0x10, 0xa1, 0xe8, 0xc7, 0x04, 0x06, 0x90, 0x4c, 0x83, 0x50, 0xce, 0xa2, 0xfc, 0x39, 0xc0 }) // Failed to write internal flash.
TRANSLATION("number of arguments must be 2, or 3", 36, { 0x4c, 0x5b, 0x22, 0x60, 0x5c, 0xc0, 0x5b, 0x4c, 0x58, 0x92, 0x1c, 0x2d, 0x87, 0x80, 0xc8, 0x83, 0xe3, 0xee, 0x05, 0x60, 0xfc, 0x80 }) // number of arguments must be 2, or 3
TRANSLATION("axis must be -1, 0, None, or 1", 31, { 0x1e, 0x46, 0xe1, 0x6c, 0x3c, 0x06, 0x44, 0x1e, 0xfe, 0x8f, 0x70, 0x6d, 0xf7, 0x07, 0x6a, 0xa1, 0x7b, 0x81, 0x58, 0x3a, 0x00 }) // axis must be -1, 0, None, or 1
TRANSLATION("object '%s' is not a tuple or list", 35, { 0x5c, 0xbf, 0x05, 0x38, 0x0d, 0x9c, 0xcf, 0xb0, 0x0d, 0xc1, 0x16, 0x00, 0x42, 0x31, 0x7a, 0x90, 0x2b, 0x05, 0x4d, 0xe0 }) // object \'%s\' is not a tuple or list
TRANSLATION("LHS of keyword arg must be an id", 33, { 0xfd, 0xff, 0xcf, 0x80, 0x2e, 0x61, 0xe4, 0x5a, 0xfa, 0x2b, 0x50, 0x05, 0xb4, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x14, 0x03, 0xa0 }) // LHS of keyword arg must be an id
TRANSLATION("Cannot set value when direction is input.", 42, { 0xea, 0x14, 0x45, 0x80, 0x72, 0x80, 0xe2, 0x35, 0xc1, 0x07, 0xa7, 0x02, 0x40, 0xa1, 0xb1, 0x4e, 0x0d, 0x50, 0x0d, 0xc0, 0xd2, 0xf8, 0x8e, 0x70 }) // Cannot set value when direction is input.
TRANSLATION("length argument not allowed for this type", 42, { 0xa9, 0x26, 0x91, 0xc0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x11, 0x60, 0x06, 0xb5, 0x5f, 0x42, 0xa0, 0x66, 0xac, 0x11, 0xc0, 0xdc, 0x23, 0x5b, 0x90 }) // length argument not allowed for this type
TRANSLATION("SPI Re-initialization error", 28, { 0xf0, 0xdf, 0xd8, 0x1d, 0xe5, 0xef, 0x34, 0x38, 0x31, 0xa9, 0xff, 0x23, 0x06, 0xa8, 0x04, 0xcc, 0xac }) // SPI Re-initialization error
TRANSLATION("cannot create '%q' instances", 29, { 0x98, 0xa2, 0x2c, 0x04, 0xd8, 0x86, 0x08, 0x36, 0x73, 0x79, 0xec, 0x03, 0x47, 0x81, 0x49, 0x93, 0x80 }) // cannot create \'%q\' instances
TRANSLATION("generator already executing", 28, { 0xd0, 0x90, 0x98, 0x61, 0x58, 0x06, 0xac, 0x43, 0x4d, 0x40, 0xb9, 0x14, 0xf1, 0x06, 0x9a, 0x00 }) // generator already executing
TRANSLATION("local variable referenced before assignment", 44, { 0xaa, 0xcc, 0x6a, 0x1c, 0x45, 0x8c, 0x72, 0xa9, 0x03, 0x16, 0x64, 0xc4, 0x93, 0x2a, 0x06, 0x45, 0x9a, 0xb1, 0x00, 0xbb, 0x9e, 0x89, 0x62, 0x48 }) // local variable referenced before assignment
TRANSLATION("overflow converting long int to machine word", 45, { 0x5e, 0x24, 0xd9, 0xd5, 0x7d, 0x02, 0x6a, 0x9c, 0x49, 0xa0, 0xd3, 0x40, 0xaa, 0xa6, 0x80, 0x69, 0x01, 0x0a, 0x16, 0x19, 0xf0, 0x34, 0x20, 0xf4, 0x56, 0xa0 }) // overflow converting long int to machine word
TRANSLATION("can't convert to int", 21, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0x85, 0x03, 0x48 }) // can\'t convert to int
TRANSLATION("I/O operation on closed file", 29, { 0xec, 0xf8, 0x77, 0x02, 0xdc, 0x98, 0x60, 0xd5, 0x01, 0x50, 0x27, 0x55, 0x72, 0xa0, 0x66, 0x75, 0x20 }) // I/O operation on closed file
TRANSLATION("No space left on device", 24, { 0xed, 0x50, 0x7b, 0x8c, 0xc8, 0x2a, 0x59, 0xc0, 0x2a, 0x05, 0x0b, 0x89, 0xcc, 0x80 }) // No space left on device
TRANSLATION("MicroPython fatal error.", 25, { 0xfb, 0x1c, 0xd9, 0x77, 0xeb, 0x1c, 0x15, 0x03, 0x31, 0x81, 0xa8, 0x13, 0x32, 0xb7, 0x38 }) // MicroPython fatal error.
TRANSLATION("type takes 1 or 3 arguments", 28, { 0x8d, 0x6e, 0x41, 0x03, 0xe4, 0x4e, 0x1d, 0x00, 0xac, 0x1f, 0x90, 0x0b, 0x69, 0x8b, 0x12, 0x43, 0x80 }) // type takes 1 or 3 arguments
TRANSLATION("Press any key to enter the REPL. Use CTRL-D to reload.", 55, { 0xde, 0xc4, 0xee, 0x02, 0x9a, 0x87, 0x91, 0x6a, 0x10, 0xa0, 0x49, 0x04, 0xc1, 0x1c, 0x08, 0x3b, 0xf7, 0x6f, 0xfd, 0xf9, 0xc3, 0xee, 0xe4, 0x1d, 0x5e, 0x3d, 0xff, 0xbf, 0xbf, 0xac, 0x21, 0x41, 0x8a, 0xaa, 0x34, 0xe7 }) // Press any key to enter the REPL. Use CTRL-D to reload.
TRANSLATION("identifier redefined as nonlocal", 33, { 0x3a, 0x12, 0x41, 0xe6, 0x64, 0xc0, 0xc5, 0x42, 0xcc, 0xd0, 0xa8, 0x02, 0xe0, 0x8a, 0x95, 0x59, 0x8d, 0x40 }) // identifier redefined as nonlocal
TRANSLATION("not all arguments converted during string formatting", 53, { 0x45, 0x80, 0x1a, 0xd4, 0x05, 0xb4, 0xc5, 0x89, 0x21, 0xc2, 0x6a, 0x9c, 0x49, 0xa0, 0xa8, 0x14, 0xc3, 0x1a, 0x68, 0x0f, 0x0c, 0x69, 0xa0, 0x66, 0xad, 0x61, 0x88, 0x34, 0xd0 }) // not all arguments converted during string formatting
TRANSLATION("first argument must be an iterable", 35, { 0xcc, 0xd9, 0xe0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x50, 0x0e, 0x09, 0x87, 0x2a, 0x90 }) // first argument must be an iterable
TRANSLATION("unsupported type for operator", 30, { 0xc2, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x04, 0x6b, 0x72, 0x0c, 0xd5, 0x81, 0x6e, 0x4c, 0x30, 0xac }) // unsupported type for operator
TRANSLATION("PulseIn not supported on this chip", 35, { 0xdf, 0x8a, 0xb9, 0x76, 0x20, 0x22, 0xc0, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x02, 0xa0, 0x47, 0x03, 0x70, 0x9f, 0x03, 0xb8 }) // PulseIn not supported on this chip
TRANSLATION("USB Error", 10, { 0xfb, 0xf8, 0x7c, 0xc3, 0x73, 0x32, 0xb0 }) // USB Error
TRANSLATION("wrong index type", 17, { 0xf4, 0x65, 0x4d, 0x00, 0xd2, 0x85, 0xc8, 0x23, 0x5b, 0x90 }) // wrong index type
TRANSLATION("can't convert %s to float", 26, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0xe6, 0x70, 0x85, 0x0c, 0xea, 0xa3, 0x00 }) // can\'t convert %s to float
TRANSLATION("expected ':' after format specifier", 36, { 0x2e, 0x57, 0x29, 0xc1, 0x50, 0x36, 0x7e, 0xdb, 0x00, 0x73, 0x82, 0x60, 0xcd, 0x5a, 0xc3, 0x00, 0xf7, 0x29, 0x9e, 0x66, 0x4c }) // expected \':\' after format specifier
TRANSLATION("Tuple or struct_time argument required", 39, { 0xf1, 0xc5, 0xea, 0x40, 0xac, 0x0f, 0x0d, 0x89, 0xc4, 0xa0, 0xec, 0x40, 0x2d, 0xa6, 0x2c, 0x49, 0x00, 0xc5, 0xe7, 0x83, 0x62, 0xa0 }) // Tuple or struct_time argument required
TRANSLATION("exceptions must derive from BaseException", 42, { 0x2e, 0x53, 0x2b, 0xc1, 0xaa, 0x38, 0x5b, 0x0f, 0x01, 0x42, 0x63, 0xe2, 0x41, 0x9b, 0x2d, 0x83, 0xe6, 0x2e, 0x5b, 0xb9, 0x4c, 0xaf, 0x06, 0xa8 }) // exceptions must derive from BaseException
TRANSLATION("Hardware in use, try alternative pins", 38, { 0xff, 0x22, 0xd4, 0xf4, 0x16, 0x20, 0x34, 0x0c, 0x39, 0x7b, 0x82, 0x1b, 0x50, 0x1a, 0xc1, 0x32, 0x0c, 0x1f, 0x12, 0x0b, 0x9a, 0x38 }) // Hardware in use, try alternative pins
TRANSLATION("ord() expected a character, but string of length %d found", 58, { 0x56, 0xa7, 0xb3, 0xda, 0x05, 0xca, 0xe5, 0x38, 0x2a, 0x00, 0x84, 0xf8, 0x0b, 0x0c, 0xe0, 0x9b, 0xdc, 0x19, 0x62, 0x01, 0xe1, 0x8d, 0x34, 0x05, 0xcc, 0x2a, 0x49, 0xa4, 0x70, 0x0e, 0x6a, 0x06, 0x6b, 0x84, 0xa0 }) // ord() expected a character, but string of length %d found
TRANSLATION("Pin does not have ADC capabilities", 35, { 0xde, 0x68, 0x14, 0x52, 0x70, 0x45, 0x80, 0xe0, 0x3c, 0x48, 0x3a, 0x7a, 0xfa, 0x82, 0x63, 0x71, 0xc8, 0xea, 0x70, 0x64, 0xe0 }) // Pin does not have ADC capabilities
TRANSLATION("PulseOut not supported on this chip", 36, { 0xdf, 0x8a, 0xb9, 0x77, 0x62, 0x01, 0x16, 0x01, 0xf1, 0x7b, 0xab, 0x41, 0x50, 0x15, 0x02, 0x38, 0x1b, 0x84, 0xf8, 0x1d, 0xc0 }) // PulseOut not supported on this chip
TRANSLATION("unmatched '{' in format", 24, { 0xc2, 0x58, 0x62, 0x7c, 0x0a, 0x81, 0xb3, 0xff, 0xbb, 0x00, 0xd0, 0x33, 0x56, 0xb0, 0xc0 }) // unmatched \'{\' in format
TRANSLATION("invalid format specifier", 25, { 0x34, 0xe2, 0x35, 0x3a, 0x06, 0x6a, 0xd6, 0x18, 0x07, 0xb9, 0x4c, 0xf3, 0x32, 0x60 }) // invalid format specifier
TRANSLATION("Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.", 101, { 0xec, 0x49, 0xad, 0xae, 0x30, 0x79, 0x54, 0x83, 0x9e, 0xd7, 0xd4, 0x33, 0x3a, 0x97, 0x38, 0x6f, 0xa9, 0x0b, 0x90, 0x62, 0xf4, 0x18, 0x20, 0x1a, 0xd4, 0x39, 0xed, 0x7d, 0x43, 0x33, 0xa9, 0x3f, 0x38, 0x78, 0x11, 0x07, 0x08, 0x8b, 0xfe, 0xdf, 0x0f, 0x80, 0xd0, 0x73, 0x6c, 0x73, 0x9c, 0x7c, 0x2d, 0x7d, 0x7d, 0xf8, 0xbd, 0x06, 0x08, 0x33, 0x56, 0x0b, 0x2b, 0x10, 0x1a, 0x66, 0xbc, 0xe0 }) // Incompatible .mpy file. Please update all .mpy files. See http://adafru.it/mpy-update for more info.
TRANSLATION("Invalid number of bits", 23, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x26, 0x2d, 0x91, 0x30, 0x2e, 0x61, 0x91, 0xc3, 0x80 }) // Invalid number of bits
TRANSLATION("rsplit(None,n)", 15, { 0x67, 0xbd, 0x4e, 0x3d, 0x9d, 0xaa, 0x85, 0xee, 0x4f, 0x68 }) // rsplit(None,n)
TRANSLATION("soft reboot\n", 14, { 0x75, 0xce, 0x01, 0x8b, 0x25, 0x58, 0xf5, 0xfa, 0x80 }) // soft reboot\r\n
TRANSLATION("function got multiple values for argument '%q'", 47, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xd1, 0x60, 0x2d, 0x8a, 0xc1, 0xde, 0xa4, 0x1c, 0x46, 0xb8, 0x27, 0x0c, 0xd5, 0x80, 0x5b, 0x4c, 0x58, 0x92, 0x03, 0x67, 0x37, 0x9e, 0xc0 }) // function got multiple values for argument \'%q\'
TRANSLATION("Permission denied", 18, { 0xde, 0x4d, 0x63, 0x77, 0x35, 0x40, 0xa1, 0x21, 0x95, 0x00 }) // Permission denied
TRANSLATION("value must fit in %d byte(s)", 29, { 0xe2, 0x35, 0xc1, 0x05, 0xb0, 0xf0, 0x19, 0x9c, 0x01, 0xa0, 0x73, 0x50, 0x32, 0xd6, 0x0b, 0xd8, 0xfe, 0xd0 }) // value must fit in %d byte(s)
TRANSLATION("UART Re-init error", 19, { 0xfb, 0xf4, 0xf7, 0xf8, 0x87, 0x79, 0x7b, 0xcd, 0x0e, 0x00, 0x99, 0x95, 0x80 }) // UART Re-init error
TRANSLATION("object not an iterator", 23, { 0x5c, 0xbf, 0x05, 0x38, 0x04, 0x58, 0x01, 0x40, 0x38, 0x26, 0x18, 0x56 }) // object not an iterator
TRANSLATION(", in %q\n", 10, { 0xf7, 0x01, 0xa0, 0x73, 0x79, 0xfa, 0xfd, 0x40 }) // , in %q\r\n
TRANSLATION("string indices must be integers, not %s", 40, { 0x78, 0x63, 0x4d, 0x00, 0xd2, 0x87, 0x32, 0x70, 0xb6, 0x1e, 0x03, 0x22, 0x03, 0x48, 0x2d, 0x09, 0x9f, 0xdc, 0x08, 0xb0, 0x1c, 0xce }) // string indices must be integers, not %s
TRANSLATION("type '%q' is not an acceptable base type", 41, { 0x8d, 0x6e, 0x41, 0xb3, 0x9b, 0xcf, 0x60, 0x1b, 0x82, 0x2c, 0x00, 0xa0, 0x0c, 0xe6, 0x57, 0x81, 0xca, 0xa4, 0x19, 0x0b, 0x90, 0x46, 0xb7, 0x20 }) // type \'%q\' is not an acceptable base type
TRANSLATION("DAC Device Init Error", 22, { 0xeb, 0xe9, 0xea, 0x0e, 0xb2, 0xe2, 0x73, 0x20, 0xec, 0x43, 0x80, 0xdc, 0xcc, 0xac }) // DAC Device Init Error
TRANSLATION("object has no len", 18, { 0x5c, 0xbf, 0x05, 0x38, 0x0e, 0x02, 0xe0, 0x8a, 0x15, 0x24 }) // object has no len
TRANSLATION("Crash into the HardFault_Handler.", 34, { 0xea, 0x61, 0x7e, 0x00, 0x69, 0x0a, 0x11, 0xc0, 0x83, 0xfc, 0x8b, 0x53, 0xe8, 0x38, 0xac, 0x4b, 0xfc, 0x8a, 0x52, 0xa4, 0xdc, 0xe0 }) // Crash into the HardFault_Handler.
TRANSLATION("axis must be None, 0, or 1", 27, { 0x1e, 0x46, 0xe1, 0x6c, 0x3c, 0x06, 0x44, 0x1d, 0xaa, 0x85, 0xee, 0x0d, 0xbe, 0xe0, 0x56, 0x0e, 0x80 }) // axis must be None, 0, or 1
TRANSLATION("too many arguments provided with the given format", 50, { 0x85, 0x50, 0xb0, 0xa6, 0xa0, 0x2d, 0xa6, 0x2c, 0x49, 0x0e, 0x17, 0x65, 0xe2, 0x74, 0x2a, 0x07, 0xa1, 0xc7, 0x00, 0x8e, 0x04, 0x1a, 0x1f, 0x12, 0x40, 0xcd, 0x5a, 0xc3, 0x00 }) // too many arguments provided with the given format
TRANSLATION("substring not found", 20, { 0x7c, 0x64, 0xf0, 0xc6, 0x9a, 0x02, 0x2c, 0x06, 0x6b, 0x84, 0xa0 }) // substring not found
TRANSLATION("No more timers available on this pin.", 38, { 0xed, 0x50, 0xb2, 0xb1, 0x04, 0x1d, 0x89, 0x9c, 0x07, 0x88, 0x9d, 0x47, 0x2a, 0x90, 0x2a, 0x04, 0x70, 0x37, 0x0b, 0x9a, 0x73, 0x80 }) // No more timers available on this pin.
TRANSLATION("object does not support item assignment", 40, { 0x5c, 0xbf, 0x05, 0x38, 0x0a, 0x29, 0x38, 0x22, 0xc0, 0x3e, 0x2f, 0x75, 0x68, 0x03, 0x82, 0xb0, 0x0b, 0xb9, 0xe8, 0x96, 0x24, 0x80 }) // object does not support item assignment
TRANSLATION("Internal define error", 22, { 0xec, 0x48, 0x26, 0x41, 0xa8, 0x50, 0xb3, 0x34, 0x20, 0x26, 0x65, 0x60 }) // Internal define error
TRANSLATION("Unsupported pull value.", 24, { 0xfb, 0xa3, 0xe2, 0xf7, 0x56, 0x82, 0xa0, 0x5f, 0x15, 0xa8, 0x71, 0x1a, 0xe0, 0xb9, 0xc0 }) // Unsupported pull value.
TRANSLATION("issubclass() arg 1 must be a class", 35, { 0x37, 0x7c, 0x65, 0x3a, 0x8b, 0xbf, 0xb3, 0xda, 0x02, 0xda, 0x07, 0x40, 0x5b, 0x0f, 0x01, 0x91, 0x00, 0x84, 0xea, 0x2e, 0xe0 }) // issubclass() arg 1 must be a class
TRANSLATION("incorrect padding", 18, { 0x34, 0x9a, 0xb3, 0x14, 0xe0, 0x2e, 0x34, 0xa1, 0xa6, 0x80 }) // incorrect padding
TRANSLATION("invalid step", 13, { 0x34, 0xe2, 0x35, 0x3a, 0x03, 0xc1, 0x5c }) // invalid step
TRANSLATION("The CircuitPython heap was corrupted because the stack was too small.\nPlease increase the stack size if you know how, or if not:", 130, { 0xf1, 0xe0, 0x41, 0xd4, 0x6d, 0x3c, 0x1c, 0x6f, 0xd6, 0x38, 0x2a, 0x07, 0x02, 0x1b, 0x87, 0xa0, 0xb8, 0x4d, 0x59, 0xb1, 0x78, 0x2a, 0x06, 0x45, 0x31, 0xc3, 0x90, 0x47, 0x02, 0x07, 0x81, 0x9f, 0x90, 0x7a, 0x0b, 0x84, 0x2a, 0x83, 0xd8, 0x6b, 0x5e, 0x7f, 0x5f, 0xab, 0x7d, 0x48, 0x5c, 0x80, 0xd2, 0x6c, 0x42, 0xe4, 0x11, 0xc0, 0x81, 0xe0, 0x67, 0xe4, 0x0e, 0x7f, 0xc9, 0x01, 0xe6, 0x1a, 0xae, 0x03, 0xc9, 0x17, 0xd0, 0x38, 0x2f, 0xa7, 0xb8, 0x15, 0x80, 0xf3, 0x04, 0x58, 0xfd, 0x80 }) // The CircuitPython heap was corrupted because the stack was too small.\r\nPlease increase the stack size if you know how, or if not:
TRANSLATION("Negative step not supported", 28, { 0xed, 0x2d, 0x06, 0x0f, 0x89, 0x03, 0xc1, 0x5c, 0x11, 0x60, 0x1f, 0x17, 0xba, 0xb4, 0x15, 0x00 }) // Negative step not supported
TRANSLATION("Unmatched number of items on RHS (expected %d, got %d).", 56, { 0xfb, 0xa5, 0x86, 0x27, 0xc0, 0xa8, 0x09, 0x8b, 0x64, 0x4c, 0x0b, 0x98, 0x1c, 0x15, 0x9c, 0x15, 0x03, 0xbf, 0xfc, 0xf8, 0x07, 0xb0, 0xb9, 0x5c, 0xa7, 0x05, 0x40, 0xe6, 0xa7, 0xb8, 0x34, 0x58, 0x0e, 0x6a, 0x7b, 0x79, 0xc0 }) // Unmatched number of items on RHS (expected %d, got %d).
TRANSLATION("name '%q' is not defined", 25, { 0x41, 0xb1, 0x06, 0xce, 0x6f, 0x3d, 0x80, 0x6e, 0x08, 0xb0, 0x14, 0x2c, 0xcd, 0x0a, 0x80 }) // name \'%q\' is not defined
TRANSLATION("I2C Init Error", 15, { 0xec, 0xf8, 0xf5, 0x07, 0x62, 0x1c, 0x06, 0xe6, 0x65, 0x60 }) // I2C Init Error
TRANSLATION("invalid syntax for number", 26, { 0x34, 0xe2, 0x35, 0x3a, 0x03, 0xea, 0x90, 0x3c, 0x83, 0x35, 0x60, 0x4c, 0x5b, 0x22, 0x60 }) // invalid syntax for number
TRANSLATION("start/end indices", 18, { 0x78, 0x16, 0x8f, 0x81, 0x25, 0x00, 0xd2, 0x87, 0x32, 0x70 }) // start/end indices
TRANSLATION("Could not start interrupt, RX busy", 35, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0xf0, 0x2d, 0x00, 0x69, 0x04, 0xcd, 0x8b, 0xc7, 0xb8, 0x3b, 0xff, 0xd8, 0x65, 0x87, 0xd4 }) // Could not start interrupt, RX busy
TRANSLATION("can't convert to float", 23, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0x85, 0x0c, 0xea, 0xa3, 0x00 }) // can\'t convert to float
TRANSLATION("AnalogOut is only 16 bits. Value must be less than 65536.", 58, { 0xe9, 0x41, 0xaa, 0xe9, 0xdd, 0x88, 0x03, 0x70, 0x54, 0xae, 0xa1, 0xd1, 0xfa, 0x06, 0x47, 0x0f, 0xce, 0x1f, 0xe8, 0x6b, 0x82, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0xa9, 0x3b, 0x84, 0x70, 0x14, 0x0f, 0xd3, 0xe5, 0xf2, 0xfc, 0xbf, 0x4e, 0x70 }) // AnalogOut is only 16 bits. Value must be less than 65536.
TRANSLATION("keywords must be strings", 25, { 0xf2, 0x2d, 0x7d, 0x15, 0xa8, 0xe1, 0x6c, 0x3c, 0x06, 0x44, 0x0f, 0x0c, 0x69, 0xa3, 0x80 }) // keywords must be strings
TRANSLATION("Running in safe mode! Not running saved code.\n", 48, { 0xef, 0xc2, 0x21, 0xa6, 0x80, 0x68, 0x0e, 0x39, 0x90, 0x59, 0x68, 0x5f, 0xf0, 0x1d, 0xab, 0x00, 0xd8, 0x44, 0x34, 0xd0, 0x1c, 0x78, 0x95, 0x02, 0x6b, 0x42, 0xe7, 0xf5, 0xfa, 0x80 }) // Running in safe mode! Not running saved code.\r\n
TRANSLATION("pop from empty list", 20, { 0xba, 0xdc, 0x33, 0x65, 0xb0, 0x15, 0xaf, 0x1a, 0x85, 0x4d, 0xe0 }) // pop from empty list
TRANSLATION("int() arg 2 must be >= 2 and <= 36", 35, { 0x34, 0x8f, 0x67, 0xb4, 0x05, 0xb4, 0x0f, 0x88, 0x5b, 0x0f, 0x01, 0x91, 0x07, 0xf8, 0xff, 0xa0, 0xf8, 0x80, 0xa5, 0x03, 0xfb, 0xff, 0xd0, 0x7e, 0x5f, 0xa0 }) // int() arg 2 must be >= 2 and <= 36
TRANSLATION("argument should be a '%q' not a '%q'", 37, { 0x16, 0xd3, 0x16, 0x24, 0x80, 0x7e, 0x0b, 0x8a, 0xd0, 0x32, 0x20, 0x10, 0xd9, 0xcd, 0xe7, 0xb0, 0x11, 0x60, 0x04, 0x36, 0x73, 0x79, 0xec }) // argument should be a \'%q\' not a \'%q\'
TRANSLATION("Cannot subclass slice", 22, { 0xea, 0x14, 0x45, 0x80, 0x7c, 0x65, 0x3a, 0x8b, 0xb8, 0x3d, 0x4e, 0x64 }) // Cannot subclass slice
TRANSLATION("'=' alignment not allowed in string format specifier", 53, { 0xd9, 0xff, 0x5b, 0x00, 0x6a, 0x7a, 0x25, 0x89, 0x20, 0x11, 0x60, 0x06, 0xb5, 0x5f, 0x42, 0xa0, 0x1a, 0x03, 0xc3, 0x1a, 0x68, 0x19, 0xab, 0x58, 0x60, 0x1e, 0xe5, 0x33, 0xcc, 0xc9, 0x80 }) // \'=\' alignment not allowed in string format specifier
TRANSLATION("format requires a dict", 23, { 0xcd, 0x5a, 0xc3, 0x00, 0xc5, 0xe7, 0x83, 0x62, 0x70, 0x10, 0xa1, 0xce, 0x00 }) // format requires a dict
TRANSLATION("Cannot remount '/' when USB is active.", 39, { 0xea, 0x14, 0x45, 0x80, 0x62, 0xb2, 0xe1, 0x20, 0x36, 0x7c, 0x36, 0x07, 0xa7, 0x02, 0x40, 0xfb, 0xf8, 0x7c, 0xc0, 0xdc, 0x06, 0x70, 0x7c, 0x4b, 0x9c }) // Cannot remount \'/\' when USB is active.
TRANSLATION("iterations did not converge", 28, { 0x38, 0x26, 0x18, 0x35, 0x47, 0x0a, 0x1d, 0x01, 0x16, 0x02, 0x6a, 0x9c, 0x49, 0xb4, 0x20 }) // iterations did not converge
TRANSLATION("Could not initialize timer", 27, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0x68, 0x70, 0x63, 0x53, 0xfe, 0x48, 0x20, 0xec, 0x4c }) // Could not initialize timer
TRANSLATION("can't do truncated division of a complex number", 48, { 0x98, 0xa6, 0xc8, 0x0a, 0x28, 0x43, 0x61, 0x26, 0x30, 0x54, 0x0a, 0x1f, 0x13, 0x73, 0x54, 0x05, 0xcc, 0x04, 0x26, 0xb6, 0xbd, 0x4b, 0x90, 0x26, 0x2d, 0x91, 0x30 }) // can\'t do truncated division of a complex number
TRANSLATION("object not iterable", 20, { 0x5c, 0xbf, 0x05, 0x38, 0x04, 0x58, 0x03, 0x82, 0x61, 0xca, 0xa4 }) // object not iterable
TRANSLATION("memory allocation failed, allocating %u bytes", 46, { 0xb1, 0x59, 0x5b, 0x50, 0x1a, 0xd5, 0x66, 0x30, 0x6a, 0x81, 0x98, 0x9d, 0x4a, 0x9e, 0xe0, 0x1a, 0xd5, 0x66, 0x30, 0x69, 0xa0, 0x73, 0x60, 0x32, 0xd6, 0x09, 0xc0 }) // memory allocation failed, allocating %u bytes
TRANSLATION("No TX pin", 10, { 0xed, 0x50, 0xf1, 0xff, 0x61, 0x73, 0x40 }) // No TX pin
TRANSLATION("can't switch from manual field specification to automatic field numbering", 74, { 0x98, 0xa6, 0xc8, 0x07, 0xf4, 0x38, 0x9f, 0x00, 0xcd, 0x96, 0xc1, 0x61, 0x4c, 0x0d, 0x43, 0x33, 0x2a, 0xd0, 0x1e, 0xe5, 0x33, 0xcc, 0xe6, 0x30, 0x6a, 0x81, 0x0a, 0x03, 0x88, 0x5b, 0x0c, 0x1c, 0xc3, 0x33, 0x2a, 0xd0, 0x13, 0x16, 0xc8, 0x98, 0xd3, 0x40 }) // can\'t switch from manual field specification to automatic field numbering
TRANSLATION("bad typecode", 13, { 0xc8, 0x68, 0x11, 0xad, 0xca, 0x6b, 0x42 }) // bad typecode
TRANSLATION("axis must be -1, 0, or 1", 25, { 0x1e, 0x46, 0xe1, 0x6c, 0x3c, 0x06, 0x44, 0x1e, 0xfe, 0x8f, 0x70, 0x6d, 0xf7, 0x02, 0xb0, 0x74, 0x00 }) // axis must be -1, 0, or 1
TRANSLATION("expecting key:value for dict", 29, { 0x2e, 0x57, 0x29, 0xc1, 0xa6, 0x81, 0xe4, 0x5a, 0xfe, 0xdc, 0x46, 0xb8, 0x20, 0xcd, 0x58, 0x28, 0x73, 0x80 }) // expecting key:value for dict
TRANSLATION("'yield' outside function", 25, { 0xd9, 0xa9, 0x95, 0x69, 0xb0, 0x17, 0x10, 0xe7, 0x42, 0x0c, 0xf0, 0x93, 0x83, 0x54 }) // \'yield\' outside function
TRANSLATION("unreadable attribute", 21, { 0xc2, 0x31, 0x0d, 0x07, 0x2a, 0x90, 0x0c, 0x43, 0x1e, 0x58, 0x82 }) // unreadable attribute
TRANSLATION("size is defined for ndarrays only", 34, { 0x73, 0xfe, 0x48, 0x0d, 0xc2, 0x85, 0x99, 0xa1, 0x50, 0x33, 0x56, 0x04, 0xa0, 0xb3, 0x0e, 0xae, 0x0a, 0x95, 0xd4 }) // size is defined for ndarrays only
TRANSLATION("unsupported types for %q: '%s', '%s'", 37, { 0xc2, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x04, 0x6b, 0x72, 0x70, 0xcd, 0x58, 0x39, 0xbc, 0xff, 0x60, 0xd9, 0xcc, 0xfb, 0x3d, 0xc1, 0xb3, 0x99, 0xf6, 0x00 }) // unsupported types for %q: \'%s\', \'%s\'
TRANSLATION("byteorder is not a string", 26, { 0xcb, 0x58, 0x25, 0x6a, 0x13, 0x01, 0xb8, 0x22, 0xc0, 0x08, 0x3c, 0x31, 0xa6, 0x80 }) // byteorder is not a string
TRANSLATION("attributes not supported yet", 29, { 0x18, 0x86, 0x3c, 0xb1, 0x04, 0xe0, 0x8b, 0x00, 0xf8, 0xbd, 0xd5, 0xa0, 0xa8, 0x1a, 0x94, 0x00 }) // attributes not supported yet
TRANSLATION("sleep length must be non-negative", 34, { 0x7a, 0x91, 0x5c, 0x2a, 0x49, 0xa4, 0x70, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x45, 0x4f, 0x7a, 0x16, 0x83, 0x07, 0xc4, 0x80 }) // sleep length must be non-negative
TRANSLATION("invalid micropython decorator", 30, { 0x34, 0xe2, 0x35, 0x3a, 0x05, 0x8e, 0x6c, 0xb7, 0xd6, 0x38, 0x2a, 0x05, 0x0a, 0x6a, 0xc3, 0x0a, 0xc0 }) // invalid micropython decorator
TRANSLATION("wrong number of arguments", 26, { 0xf4, 0x65, 0x4d, 0x01, 0x31, 0x6c, 0x89, 0x81, 0x73, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x70 }) // wrong number of arguments
TRANSLATION("unindent does not match any outer indentation level", 52, { 0xc2, 0x1a, 0x50, 0x92, 0x02, 0x8a, 0x4e, 0x08, 0xb0, 0x16, 0x18, 0x9f, 0x00, 0x14, 0xd4, 0x17, 0x10, 0x4c, 0x06, 0x94, 0x24, 0x81, 0x83, 0x54, 0x0a, 0x97, 0x12, 0xa8 }) // unindent does not match any outer indentation level
TRANSLATION("Could not restart PWM", 22, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0xc4, 0xf0, 0x2d, 0x01, 0xbf, 0xf8, 0xfb, 0x00 }) // Could not restart PWM
TRANSLATION("UART Buffer allocation error", 29, { 0xfb, 0xf4, 0xf7, 0xf8, 0x87, 0xcf, 0x19, 0xe6, 0x4c, 0x03, 0x5a, 0xac, 0xc6, 0x0d, 0x50, 0x09, 0x99, 0x58 }) // UART Buffer allocation error
TRANSLATION("'%s' object has no attribute '%q'", 34, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x38, 0x0b, 0x82, 0x28, 0x0c, 0x43, 0x1e, 0x58, 0x82, 0x0d, 0x9c, 0xde, 0x7b, 0x00 }) // \'%s\' object has no attribute \'%q\'
TRANSLATION("right hand side must be an ndarray, or a scalar", 48, { 0x63, 0xd3, 0x84, 0x07, 0x01, 0x4a, 0x03, 0x9d, 0x08, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x50, 0x12, 0x82, 0xcc, 0x3a, 0xfb, 0x81, 0x58, 0x04, 0x1e, 0x63, 0x51, 0x60 }) // right hand side must be an ndarray, or a scalar
TRANSLATION("%q in use", 10, { 0xe6, 0xf3, 0x03, 0x40, 0xc3, 0x90 }) // %q in use
TRANSLATION("cannot create instance", 23, { 0x98, 0xa2, 0x2c, 0x04, 0xd8, 0x86, 0x08, 0x0d, 0x1e, 0x05, 0x26, 0x40 }) // cannot create instance
TRANSLATION("object not in sequence", 23, { 0x5c, 0xbf, 0x05, 0x38, 0x04, 0x58, 0x03, 0x40, 0x72, 0xf3, 0xc1, 0x24, 0xc8 }) // object not in sequence
TRANSLATION("wrong operand type", 19, { 0xf4, 0x65, 0x4d, 0x01, 0x6e, 0x4c, 0x29, 0x40, 0x8d, 0x6e, 0x40 }) // wrong operand type
TRANSLATION("Error in regex", 15, { 0xdc, 0xcc, 0xac, 0x06, 0x80, 0xc5, 0xa1, 0x72 }) // Error in regex
TRANSLATION("arguments must be ndarrays", 27, { 0x16, 0xd3, 0x16, 0x24, 0x87, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x4a, 0x0b, 0x30, 0xea, 0xe0 }) // arguments must be ndarrays
TRANSLATION("Invalid argument", 17, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x0b, 0x69, 0x8b, 0x12, 0x40 }) // Invalid argument
TRANSLATION("no module named '%q'", 21, { 0x45, 0x0b, 0x2d, 0x31, 0x52, 0x04, 0x1b, 0x15, 0x03, 0x67, 0x37, 0x9e, 0xc0 }) // no module named \'%q\'
TRANSLATION("pop from an empty PulseIn", 26, { 0xba, 0xdc, 0x33, 0x65, 0xb0, 0x0a, 0x01, 0x5a, 0xf1, 0xa8, 0x6f, 0xc5, 0x5c, 0xbb, 0x10 }) // pop from an empty PulseIn
TRANSLATION("flattening order must be either 'C', or 'F'", 44, { 0xce, 0xa3, 0x10, 0x48, 0x69, 0xa0, 0x2b, 0x50, 0x98, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x8e, 0x38, 0x13, 0x06, 0xce, 0xad, 0x9e, 0xe0, 0x56, 0x0d, 0x9f, 0x4d, 0x80 }) // flattening order must be either \'C\', or \'F\'
TRANSLATION("CircuitPython core code crashed hard. Whoops!\n", 48, { 0xea, 0x36, 0x9e, 0x0e, 0x37, 0xeb, 0x1c, 0x15, 0x02, 0x6a, 0xc4, 0x13, 0x5a, 0x10, 0x4d, 0x85, 0xf8, 0x15, 0x03, 0x80, 0xb5, 0x39, 0xc3, 0xf8, 0xe0, 0xab, 0x77, 0xff, 0x8f, 0x5f, 0xa8 }) // CircuitPython core code crashed hard. Whoops!\r\n
TRANSLATION("Pull not used when direction is output.", 40, { 0xdf, 0x8a, 0xd4, 0x11, 0x60, 0x30, 0xe5, 0x40, 0xf4, 0xe0, 0x48, 0x14, 0x36, 0x29, 0xc1, 0xaa, 0x01, 0xb8, 0x2e, 0x22, 0xf8, 0x8e, 0x70 }) // Pull not used when direction is output.
TRANSLATION("Array must contain halfwords (type 'H')", 40, { 0xe9, 0x66, 0x1d, 0x42, 0xd8, 0x78, 0x09, 0xaa, 0x40, 0x9a, 0x07, 0x01, 0xae, 0x7e, 0x8a, 0xd4, 0x70, 0xf6, 0x46, 0xb7, 0x20, 0xd9, 0xfe, 0x76, 0x7b, 0x40 }) // Array must contain halfwords (type \'H\')
TRANSLATION("zero step", 10, { 0xfe, 0x49, 0x94, 0x1e, 0x0a, 0xe0 }) // zero step
TRANSLATION("RTC is not supported on this board", 35, { 0xef, 0xf1, 0xea, 0x03, 0x70, 0x45, 0x80, 0x7c, 0x5e, 0xea, 0xd0, 0x54, 0x05, 0x40, 0x8e, 0x06, 0xe1, 0x92, 0x8b, 0x50 }) // RTC is not supported on this board
TRANSLATION("Name too long", 14, { 0xed, 0x1b, 0x10, 0x42, 0xa8, 0x55, 0x53, 0x40 }) // Name too long
TRANSLATION("function missing required positional argument #%d", 50, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xb1, 0xbb, 0x9a, 0x68, 0x0c, 0x5e, 0x78, 0x36, 0x2a, 0x05, 0xd5, 0xce, 0x0d, 0x50, 0x6a, 0x02, 0xda, 0x62, 0xc4, 0x90, 0x1f, 0xf3, 0xcd, 0x40 }) // function missing required positional argument #%d
TRANSLATION("Invalid byteorder string", 25, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x65, 0xac, 0x12, 0xb5, 0x09, 0x81, 0xe1, 0x8d, 0x34 }) // Invalid byteorder string
TRANSLATION("Read-only", 10, { 0xef, 0x21, 0xa7, 0xbd, 0x52, 0xba, 0x80 }) // Read-only
TRANSLATION("can't assign to expression", 27, { 0x98, 0xa6, 0xc8, 0x01, 0x77, 0x3d, 0x10, 0x21, 0x40, 0xb9, 0x5d, 0x89, 0xdc, 0xd5, 0x00 }) // can\'t assign to expression
TRANSLATION("USB Busy", 9, { 0xfb, 0xf8, 0x7c, 0xc3, 0xe7, 0x87, 0xd4 }) // USB Busy
TRANSLATION("Could not re-init channel", 26, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0xc5, 0xef, 0x34, 0x38, 0x09, 0xf0, 0x14, 0x42, 0xa8 }) // Could not re-init channel
TRANSLATION("The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\n", 95, { 0xf1, 0xe0, 0x41, 0xff, 0x96, 0x39, 0xb2, 0xcd, 0x52, 0x19, 0x6b, 0x52, 0x6f, 0xfc, 0x0b, 0x2d, 0x31, 0x52, 0x0f, 0x41, 0x70, 0xc3, 0x95, 0x02, 0x14, 0x32, 0x55, 0x80, 0x34, 0x85, 0x07, 0x1c, 0xc8, 0x2c, 0xb4, 0x2e, 0x70, 0xde, 0xc4, 0xee, 0x0c, 0x4e, 0x50, 0x10, 0xa0, 0x5c, 0x8e, 0x01, 0xc7, 0x32, 0x0b, 0x2d, 0x0b, 0x9f, 0xd7, 0xea }) // The `microcontroller` module was used to boot into safe mode. Press reset to exit safe mode.\r\n
TRANSLATION("Corrupt .mpy file", 18, { 0xea, 0x56, 0x6c, 0x5e, 0x03, 0x9e, 0xd7, 0xd4, 0x33, 0x3a, 0x90 }) // Corrupt .mpy file
TRANSLATION("multiple bases have instance lay-out conflict", 46, { 0xb6, 0x2b, 0x07, 0x7a, 0x90, 0x64, 0x2e, 0x4e, 0x1c, 0x07, 0x89, 0x01, 0xa3, 0xc0, 0xa4, 0xc8, 0x2a, 0x3a, 0xfb, 0xd7, 0x10, 0x13, 0x54, 0xce, 0xa7, 0x38 }) // multiple bases have instance lay-out conflict
TRANSLATION("Invalid buffer size", 20, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x65, 0x8c, 0xf3, 0x26, 0x07, 0x3f, 0xe4, 0x80 }) // Invalid buffer size
TRANSLATION("super() can't find self", 24, { 0x7c, 0x5c, 0x9b, 0xd9, 0xed, 0x09, 0x8a, 0x6c, 0x80, 0xcc, 0xd2, 0x80, 0xe5, 0x5c, 0xc0 }) // super() can\'t find self
TRANSLATION("popitem(): dictionary is empty", 31, { 0xba, 0xdc, 0xe0, 0xad, 0xec, 0xf6, 0xfe, 0xc1, 0x43, 0x9c, 0x1a, 0xa0, 0xb6, 0xa0, 0x6e, 0x05, 0x6b, 0xc6, 0xa0 }) // popitem(): dictionary is empty
TRANSLATION("\nPlease file an issue with the contents of your CIRCUITPY drive at \nhttps://github.com/adafruit/circuitpython/issues\n", 121, { 0xf5, 0xfa, 0xb7, 0xd4, 0x85, 0xc8, 0x33, 0x3a, 0x90, 0x0a, 0x01, 0xbb, 0xe0, 0x83, 0xd0, 0xe3, 0x80, 0x47, 0x02, 0x09, 0xaa, 0x41, 0x24, 0x38, 0x2e, 0x61, 0xaa, 0xe1, 0x83, 0xab, 0xb3, 0xbf, 0xab, 0xef, 0xd9, 0xe3, 0xbf, 0xfe, 0xc2, 0x8c, 0x7c, 0x48, 0x06, 0x03, 0xd7, 0xea, 0xe1, 0x11, 0x77, 0xfd, 0xbe, 0x1f, 0x0d, 0x0e, 0x38, 0x63, 0x2e, 0x79, 0xad, 0xbe, 0x03, 0x41, 0xcd, 0xb0, 0x71, 0xf0, 0x99, 0xb4, 0xf0, 0x71, 0x7d, 0x63, 0x82, 0xa7, 0xc0, 0xdd, 0xf0, 0x4f, 0xeb, 0xf5, 0x00 }) // \r\nPlease file an issue with the contents of your CIRCUITPY drive at \r\nhttps://github.com/adafruit/circuitpython/issues\r\n
TRANSLATION("incomplete format key", 22, { 0x34, 0x9a, 0xda, 0xf5, 0x28, 0x20, 0xcd, 0x5a, 0xc3, 0x01, 0xe4, 0x5a, 0x80 }) // incomplete format key
TRANSLATION("Hardware busy, try alternative pins", 36, { 0xff, 0x22, 0xd4, 0xf4, 0x16, 0x20, 0xcb, 0x0f, 0xaf, 0xb8, 0x21, 0xb5, 0x01, 0xac, 0x13, 0x20, 0xc1, 0xf1, 0x20, 0xb9, 0xa3, 0x80 }) // Hardware busy, try alternative pins
TRANSLATION("name reused for argument", 25, { 0x41, 0xb1, 0x03, 0x16, 0x1c, 0xa8, 0x19, 0xab, 0x00, 0xb6, 0x98, 0xb1, 0x24, 0x00 }) // name reused for argument
TRANSLATION("All timers in use", 18, { 0xe9, 0xad, 0x42, 0x0e, 0xc4, 0xce, 0x06, 0x81, 0x87, 0x20 }) // All timers in use
TRANSLATION("shape must be a 2-tuple", 24, { 0x7e, 0x03, 0x72, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x10, 0xf8, 0xfb, 0xe3, 0x17, 0xa9, 0x00 }) // shape must be a 2-tuple
TRANSLATION("array/bytes required on right side", 35, { 0x16, 0x61, 0xd7, 0xe1, 0x96, 0xb0, 0x4e, 0x0c, 0x5e, 0x78, 0x36, 0x2a, 0x02, 0xa0, 0x31, 0xe9, 0xc2, 0x01, 0xce, 0x84 }) // array/bytes required on right side
TRANSLATION("identifier redefined as global", 31, { 0x3a, 0x12, 0x41, 0xe6, 0x64, 0xc0, 0xc5, 0x42, 0xcc, 0xd0, 0xa8, 0x02, 0xe1, 0xa5, 0x57, 0x21, 0xa8 }) // identifier redefined as global
TRANSLATION("function missing %d required positional arguments", 50, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xb1, 0xbb, 0x9a, 0x68, 0x1c, 0xd4, 0x06, 0x2f, 0x3c, 0x1b, 0x15, 0x02, 0xea, 0xe7, 0x06, 0xa8, 0x35, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x70 }) // function missing %d required positional arguments
TRANSLATION("Invalid phase", 14, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x5f, 0x80, 0xb9, 0x00 }) // Invalid phase
TRANSLATION("'continue' outside loop", 24, { 0xd9, 0x35, 0x48, 0x34, 0xc1, 0x6c, 0x05, 0xc4, 0x39, 0xd0, 0x82, 0xaa, 0xb7 }) // \'continue\' outside loop
TRANSLATION("byte code not implemented", 26, { 0xcb, 0x58, 0x20, 0x9a, 0xd0, 0x81, 0x16, 0x00, 0xed, 0x7a, 0x95, 0x89, 0x20, 0xa8 }) // byte code not implemented
TRANSLATION("Invalid pin", 12, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x5c, 0xd0 }) // Invalid pin
TRANSLATION("cannot import name %q", 22, { 0x98, 0xa2, 0x2c, 0x01, 0xda, 0xea, 0xd0, 0x08, 0x36, 0x20, 0xe6, 0xf3 }) // cannot import name %q
TRANSLATION("join expects a list of str/bytes objects consistent with self object", 69, { 0xfc, 0x29, 0xa0, 0x17, 0x2b, 0x94, 0xe1, 0xc0, 0x42, 0xa6, 0xf0, 0x0b, 0x98, 0x3c, 0x37, 0xc3, 0x2d, 0x60, 0x9c, 0x17, 0x2f, 0xc1, 0x4e, 0x1c, 0x26, 0xa8, 0xe6, 0xf0, 0x49, 0x01, 0xe8, 0x71, 0xc0, 0x1c, 0xab, 0x98, 0x2e, 0x5f, 0x82, 0x9c, 0x00 }) // join expects a list of str/bytes objects consistent with self object
TRANSLATION("arctan2 is implemented for scalars and ndarrays only", 53, { 0x16, 0x9c, 0x0a, 0x7c, 0x40, 0xdc, 0x0e, 0xd7, 0xa9, 0x58, 0x92, 0x0a, 0x81, 0x9a, 0xb0, 0x3c, 0xc6, 0xa2, 0xce, 0x02, 0x94, 0x04, 0xa0, 0xb3, 0x0e, 0xae, 0x0a, 0x95, 0xd4 }) // arctan2 is implemented for scalars and ndarrays only
TRANSLATION("can't delete expression", 24, { 0x98, 0xa6, 0xc8, 0x0a, 0x15, 0x4a, 0x08, 0x0b, 0x95, 0xd8, 0x9d, 0xcd, 0x50 }) // can\'t delete expression
TRANSLATION("maximum recursion depth exceeded", 33, { 0xb0, 0xf2, 0x3b, 0x62, 0xc0, 0xc5, 0x3c, 0x33, 0x9a, 0xa0, 0x50, 0xaf, 0x1c, 0x00, 0xb9, 0x4c, 0x8a, 0x85, 0x40 }) // maximum recursion depth exceeded
TRANSLATION("can't convert to complex", 25, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0x85, 0x09, 0xad, 0xaf, 0x52, 0xe4 }) // can\'t convert to complex
TRANSLATION("unexpected indent", 18, { 0xc2, 0x17, 0x2b, 0x94, 0xe0, 0xa8, 0x06, 0x94, 0x24, 0x80 }) // unexpected indent
TRANSLATION("Invalid memory access.", 23, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x58, 0xac, 0xad, 0xa8, 0x0c, 0xe6, 0x4e, 0xfc, 0xe0 }) // Invalid memory access.
TRANSLATION("module not found", 17, { 0xb2, 0xd3, 0x15, 0x20, 0x45, 0x80, 0xcd, 0x70, 0x94 }) // module not found
TRANSLATION("step must be non-zero", 22, { 0x78, 0x2b, 0x85, 0xb0, 0xf0, 0x19, 0x10, 0x22, 0xa7, 0xbf, 0xf9, 0x26, 0x50 }) // step must be non-zero
TRANSLATION("empty sequence", 15, { 0x2b, 0x5e, 0x35, 0x07, 0x2f, 0x3c, 0x12, 0x4c, 0x80 }) // empty sequence
TRANSLATION("Call super().__init__() before accessing native object.", 56, { 0xea, 0x1a, 0xd4, 0x1f, 0x17, 0x26, 0xf6, 0x7b, 0x79, 0xe5, 0x23, 0x43, 0x89, 0x4b, 0xd9, 0xed, 0x0c, 0x8b, 0x35, 0x62, 0x01, 0x9c, 0xc9, 0xdc, 0xd3, 0x40, 0x41, 0x83, 0xe2, 0x40, 0xb9, 0x7e, 0x0a, 0x71, 0xce }) // Call super().__init__() before accessing native object.
TRANSLATION("Brightness must be between 0 and 255", 37, { 0xf9, 0xb1, 0xe9, 0xc2, 0x10, 0x9d, 0xc2, 0xd8, 0x78, 0x0c, 0x88, 0x32, 0x28, 0xf4, 0x22, 0x40, 0xda, 0x02, 0x94, 0x0f, 0x8f, 0xcb, 0xe4 }) // Brightness must be between 0 and 255
TRANSLATION("Unknown reason.", 16, { 0xfb, 0xa7, 0x92, 0x2f, 0xa2, 0x03, 0x10, 0xba, 0xa7, 0x38 }) // Unknown reason.
TRANSLATION("All timers for this pin are in use", 35, { 0xe9, 0xad, 0x42, 0x0e, 0xc4, 0xce, 0x19, 0xab, 0x04, 0x70, 0x37, 0x0b, 0x9a, 0x00, 0xb1, 0x01, 0xa0, 0x61, 0xc8 }) // All timers for this pin are in use
TRANSLATION("unsupported format character '%c' (0x%x) at index %d", 53, { 0xc2, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x06, 0x6a, 0xd6, 0x18, 0x09, 0xf0, 0x16, 0x19, 0xc1, 0x30, 0x6c, 0xe6, 0x9e, 0xc0, 0xf6, 0x6d, 0xe5, 0xcd, 0xcb, 0xda, 0x03, 0x00, 0x69, 0x42, 0xe4, 0x1c, 0xd4 }) // unsupported format character \'%c\' (0x%x) at index %d
TRANSLATION("not enough arguments for format string", 39, { 0x45, 0x80, 0x24, 0x5c, 0x69, 0xc0, 0x05, 0xb4, 0xc5, 0x89, 0x21, 0xc3, 0x35, 0x60, 0xcd, 0x5a, 0xc3, 0x00, 0xf0, 0xc6, 0x9a, 0x00 }) // not enough arguments for format string
TRANSLATION("pop from an empty set", 22, { 0xba, 0xdc, 0x33, 0x65, 0xb0, 0x0a, 0x01, 0x5a, 0xf1, 0xa8, 0x39, 0x40 }) // pop from an empty set
TRANSLATION("Must provide MISO or MOSI pin", 30, { 0xfb, 0x61, 0xe0, 0x2e, 0xcb, 0xc4, 0xe8, 0x41, 0xf6, 0xec, 0xf0, 0xee, 0x05, 0x60, 0xfb, 0x77, 0x78, 0x76, 0x05, 0xcd, 0x00 }) // Must provide MISO or MOSI pin
TRANSLATION("Welcome to Adafruit CircuitPython %s!\n\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\n\nTo list built-in modules please do `help(\"modules\")`.\n", 175, { 0xfe, 0x0a, 0xb3, 0x5b, 0x10, 0x42, 0x87, 0x4d, 0x07, 0x36, 0xc1, 0xc0, 0x75, 0x1b, 0x4f, 0x07, 0x1b, 0xf5, 0x8e, 0x0a, 0x81, 0xcc, 0xff, 0xf1, 0xeb, 0xf5, 0x7a, 0xfd, 0x5b, 0xea, 0x42, 0xe4, 0x1c, 0x4d, 0xce, 0x02, 0xa4, 0x2c, 0x9c, 0xe3, 0x41, 0xcd, 0xb0, 0x71, 0xcf, 0x35, 0xb7, 0xc2, 0x63, 0x05, 0xa2, 0xb6, 0xbf, 0x09, 0x9b, 0x4f, 0x07, 0x17, 0xd6, 0x38, 0x2a, 0x06, 0x6a, 0xc1, 0x76, 0x5f, 0xc1, 0x4e, 0x03, 0x4c, 0x1d, 0x09, 0xf9, 0xfd, 0x7e, 0xaf, 0x5f, 0xab, 0xc5, 0x42, 0xa6, 0xf0, 0x19, 0x60, 0xeb, 0x1e, 0xf3, 0x40, 0xb2, 0xd3, 0x15, 0x27, 0x0b, 0xd4, 0x85, 0xc8, 0x28, 0xa1, 0xff, 0x9c, 0x0a, 0xb7, 0xf6, 0x7f, 0xea, 0xcb, 0x4c, 0x54, 0x9f, 0xff, 0x5e, 0xdf, 0xfc, 0xe7, 0xf5, 0xfa, 0x80 }) // Welcome to Adafruit CircuitPython %s!\r\n\r\nPlease visit learn.adafruit.com/category/circuitpython for project guides.\r\n\r\nTo list built-in modules please do `help(\"modules\")`.\r\n
TRANSLATION("timestamp out of range for platform time_t", 43, { 0x83, 0xb1, 0x3c, 0x0d, 0xae, 0x0b, 0x88, 0x05, 0xcc, 0x18, 0x53, 0x42, 0x0c, 0xd5, 0x82, 0xf5, 0x18, 0xcd, 0x5a, 0xc1, 0x07, 0x62, 0x94, 0x00 }) // timestamp out of range for platform time_t
TRANSLATION("extra positional arguments given", 33, { 0x2e, 0x50, 0xc2, 0x17, 0x57, 0x38, 0x35, 0x41, 0xa8, 0x0b, 0x69, 0x8b, 0x12, 0x43, 0x86, 0x87, 0xc4, 0x90 }) // extra positional arguments given
TRANSLATION("can't convert inf to int", 25, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0x34, 0xcc, 0x21, 0x40, 0xd2, 0x00 }) // can\'t convert inf to int
TRANSLATION("can't have multiple *x", 23, { 0x98, 0xa6, 0xc8, 0x0e, 0x03, 0xc4, 0x82, 0xd8, 0xac, 0x1d, 0xea, 0x41, 0xfd, 0x39, 0x00 }) // can\'t have multiple *x
TRANSLATION("'break' outside loop", 21, { 0xd9, 0x93, 0x10, 0xf9, 0x6c, 0x05, 0xc4, 0x39, 0xd0, 0x82, 0xaa, 0xb7 }) // \'break\' outside loop
TRANSLATION("type object '%q' has no attribute '%q'", 39, { 0x8d, 0x6e, 0x40, 0xb9, 0x7e, 0x0a, 0x70, 0x1b, 0x39, 0xbc, 0xf6, 0x07, 0x01, 0x70, 0x45, 0x01, 0x88, 0x63, 0xcb, 0x10, 0x41, 0xb3, 0x9b, 0xcf, 0x60 }) // type object \'%q\' has no attribute \'%q\'
TRANSLATION("'%s' object is not subscriptable", 33, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x0d, 0xc1, 0x16, 0x01, 0xf1, 0x93, 0xcd, 0x8e, 0xf0, 0x39, 0x54, 0x80 }) // \'%s\' object is not subscriptable
TRANSLATION("input data must be an iterable", 31, { 0x34, 0xbe, 0x20, 0x28, 0x30, 0x21, 0x6c, 0x3c, 0x06, 0x44, 0x02, 0x80, 0x70, 0x4c, 0x39, 0x54, 0x80 }) // input data must be an iterable
TRANSLATION("can't convert %s to int", 24, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0xe6, 0x70, 0x85, 0x03, 0x48 }) // can\'t convert %s to int
TRANSLATION("malformed f-string", 19, { 0xb0, 0xd7, 0x35, 0x6b, 0x15, 0x03, 0x3f, 0x7b, 0xc3, 0x1a, 0x68 }) // malformed f-string
TRANSLATION("can't have multiple **x", 24, { 0x98, 0xa6, 0xc8, 0x0e, 0x03, 0xc4, 0x82, 0xd8, 0xac, 0x1d, 0xea, 0x41, 0xfd, 0x3f, 0xa7, 0x20 }) // can\'t have multiple **x
TRANSLATION("Input/output error", 19, { 0xec, 0x4b, 0xe2, 0x3e, 0x0b, 0x88, 0xbe, 0x20, 0x09, 0x99, 0x58 }) // Input/output error
TRANSLATION("Object has been deinitialized and can no longer be used. Create a new object.", 78, { 0xee, 0xcb, 0xf0, 0x53, 0x80, 0xe0, 0x2e, 0x19, 0x11, 0x20, 0x50, 0x8d, 0x0e, 0x0c, 0x6a, 0x7f, 0xc9, 0x50, 0x05, 0x28, 0x13, 0x14, 0x04, 0x50, 0xaa, 0xa6, 0x84, 0xc1, 0x91, 0x06, 0x1c, 0xa9, 0xce, 0x1d, 0x4c, 0x43, 0x04, 0x02, 0x08, 0x5e, 0x80, 0xb9, 0x7e, 0x0a, 0x71, 0xce }) // Object has been deinitialized and can no longer be used. Create a new object.
TRANSLATION("integer required", 17, { 0x34, 0x82, 0xd0, 0x98, 0x18, 0xbc, 0xf0, 0x6c, 0x54 }) // integer required
TRANSLATION("function expected at most %d arguments, got %d", 47, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0x2e, 0x57, 0x29, 0xc1, 0x50, 0x06, 0x02, 0xca, 0xf0, 0x1c, 0xd4, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x7f, 0x70, 0x68, 0xb0, 0x1c, 0xd4 }) // function expected at most %d arguments, got %d
TRANSLATION("empty separator", 16, { 0x2b, 0x5e, 0x35, 0x07, 0x2b, 0x8b, 0x0c, 0x2b, 0x00 }) // empty separator
TRANSLATION("No default %q bus", 18, { 0xed, 0x50, 0xa1, 0x66, 0x38, 0xac, 0x07, 0x37, 0x98, 0x65, 0x87 }) // No default %q bus
TRANSLATION("'%s' object is not callable", 28, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x0d, 0xc1, 0x16, 0x02, 0x63, 0x5a, 0x8e, 0x55, 0x20 }) // \'%s\' object is not callable
TRANSLATION("expected tuple/list", 20, { 0x2e, 0x57, 0x29, 0xc1, 0x50, 0x23, 0x17, 0xa9, 0x7c, 0x2a, 0x6f, 0x00 }) // expected tuple/list
TRANSLATION("%q() takes %d positional arguments but %d were given", 53, { 0xe6, 0xf3, 0xf6, 0x7b, 0x42, 0x07, 0xc8, 0x9c, 0x39, 0xa8, 0x17, 0x57, 0x38, 0x35, 0x41, 0xa8, 0x0b, 0x69, 0x8b, 0x12, 0x43, 0x86, 0x58, 0x80, 0xe6, 0xa0, 0x7a, 0x13, 0x10, 0x68, 0x7c, 0x49, 0x00 }) // %q() takes %d positional arguments but %d were given
TRANSLATION("Invalid SPI pin selection", 26, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x78, 0x6f, 0xec, 0x0b, 0x9a, 0x03, 0x95, 0x4a, 0x70, 0x6a, 0x80 }) // Invalid SPI pin selection
TRANSLATION("stream operation not supported", 31, { 0x78, 0x62, 0x1b, 0x02, 0xdc, 0x98, 0x60, 0xd5, 0x01, 0x16, 0x01, 0xf1, 0x7b, 0xab, 0x41, 0x50 }) // stream operation not supported
TRANSLATION("No such file/directory", 23, { 0xed, 0x50, 0x7c, 0x4f, 0x80, 0x66, 0x75, 0x2f, 0x85, 0x0d, 0x8a, 0x70, 0xad, 0xa8 }) // No such file/directory
TRANSLATION("DAC Channel Init Error", 23, { 0xeb, 0xe9, 0xea, 0x0e, 0xae, 0x02, 0x88, 0x55, 0x0e, 0xc4, 0x38, 0x0d, 0xcc, 0xca, 0xc0 }) // DAC Channel Init Error
TRANSLATION("Invalid UART pin selection", 27, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x7d, 0xfa, 0x7b, 0xfc, 0x42, 0xe6, 0x80, 0xe5, 0x52, 0x9c, 0x1a, 0xa0 }) // Invalid UART pin selection
TRANSLATION("argsort argument must be an ndarray", 36, { 0x16, 0xd1, 0xd5, 0xa0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x50, 0x12, 0x82, 0xcc, 0x3a, 0x80 }) // argsort argument must be an ndarray
TRANSLATION("syntax error in JSON", 21, { 0x7d, 0x52, 0x07, 0x90, 0x13, 0x32, 0xb0, 0x1a, 0x07, 0xff, 0xde, 0x1d, 0xdd, 0xa0 }) // syntax error in JSON
TRANSLATION("PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)", 73, { 0xdf, 0xfc, 0x7d, 0x82, 0x98, 0x8d, 0x65, 0x3d, 0x67, 0x52, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0xc8, 0xa3, 0xd0, 0x89, 0x03, 0x68, 0x0a, 0x50, 0x3f, 0x4f, 0x97, 0xcb, 0xf2, 0xf9, 0x01, 0xa4, 0xeb, 0x87, 0x3e, 0x24, 0x1e, 0xce, 0x8f, 0xd0, 0x32, 0x38, 0x06, 0x27, 0x5a, 0xe2, 0x0d, 0x53, 0xda }) // PWM duty_cycle must be between 0 and 65535 inclusive (16 bit resolution)
TRANSLATION("input vectors must be of equal length", 38, { 0x34, 0xbe, 0x20, 0x38, 0x94, 0xe1, 0x59, 0xc2, 0xd8, 0x78, 0x0c, 0x88, 0x17, 0x30, 0x2f, 0x3c, 0x0d, 0x42, 0xa4, 0x9a, 0x47, 0x00 }) // input vectors must be of equal length
TRANSLATION("object not callable", 20, { 0x5c, 0xbf, 0x05, 0x38, 0x04, 0x58, 0x09, 0x8d, 0x6a, 0x39, 0x54, 0x80 }) // object not callable
TRANSLATION("input must be square matrix", 28, { 0x34, 0xbe, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x81, 0xfc, 0xf0, 0x2c, 0x41, 0x61, 0x86, 0x3e, 0x40 }) // input must be square matrix
TRANSLATION("only slices with step=1 (aka None) are supported", 49, { 0x54, 0xae, 0xa0, 0xf5, 0x39, 0x93, 0x87, 0xa1, 0xc7, 0x00, 0x78, 0x2b, 0xff, 0xd7, 0x40, 0x7b, 0x07, 0xc8, 0x43, 0xb5, 0x50, 0xbd, 0xa0, 0x2c, 0x40, 0xf8, 0xbd, 0xd5, 0xa0, 0xa8 }) // only slices with step=1 (aka None) are supported
TRANSLATION("SPI Init Error", 15, { 0xf0, 0xdf, 0xd8, 0x1d, 0x88, 0x70, 0x1b, 0x99, 0x95, 0x80 }) // SPI Init Error
TRANSLATION("Invalid PWM frequency", 22, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x6f, 0xfe, 0x3e, 0xc1, 0x9b, 0x17, 0x9e, 0x09, 0x27, 0xa8 }) // Invalid PWM frequency
TRANSLATION("non-hex digit found", 20, { 0x45, 0x4f, 0x7f, 0x02, 0xe4, 0x14, 0x3d, 0x0e, 0x03, 0x35, 0xc2, 0x50 }) // non-hex digit found
TRANSLATION("convolve arguments must be linear arrays", 41, { 0x9a, 0xa7, 0x15, 0xaf, 0x12, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x70, 0xb6, 0x1e, 0x03, 0x22, 0x0a, 0x9a, 0x10, 0xb0, 0x0b, 0x30, 0xea, 0xe0 }) // convolve arguments must be linear arrays
TRANSLATION("can't convert '%q' object to %q implicitly", 43, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0xd9, 0xcd, 0xe7, 0xb0, 0x17, 0x2f, 0xc1, 0x4e, 0x02, 0x14, 0x39, 0xbc, 0xc0, 0xed, 0x7a, 0x9c, 0xce, 0x2b, 0xa8 }) // can\'t convert \'%q\' object to %q implicitly
TRANSLATION("No RX pin", 10, { 0xed, 0x50, 0xef, 0xff, 0x61, 0x73, 0x40 }) // No RX pin
TRANSLATION("Corrupt raw code", 17, { 0xea, 0x56, 0x6c, 0x5e, 0x01, 0x87, 0xd0, 0x26, 0xb4, 0x20 }) // Corrupt raw code
TRANSLATION("attempt to get argmin/argmax of an empty sequence", 50, { 0x18, 0x82, 0xb5, 0xe0, 0x21, 0x43, 0x42, 0x80, 0x16, 0xd2, 0xc6, 0x9f, 0x01, 0x6d, 0x2c, 0x3c, 0x81, 0x73, 0x01, 0x40, 0x2b, 0x5e, 0x35, 0x07, 0x2f, 0x3c, 0x12, 0x4c, 0x80 }) // attempt to get argmin/argmax of an empty sequence
TRANSLATION("Function requires lock", 23, { 0xfa, 0x61, 0x27, 0x06, 0xa8, 0x0c, 0x5e, 0x78, 0x36, 0x27, 0x0a, 0xac, 0xfc, 0x80 }) // Function requires lock
TRANSLATION("input argument must be an integer or a 2-tuple", 47, { 0x34, 0xbe, 0x20, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x50, 0x0d, 0x20, 0xb4, 0x26, 0x05, 0x60, 0x10, 0xf8, 0xfb, 0xe3, 0x17, 0xa9, 0x00 }) // input argument must be an integer or a 2-tuple
TRANSLATION("cannot reshape array (incompatible input/output shape)", 55, { 0x98, 0xa2, 0x2c, 0x03, 0x13, 0xf0, 0x1b, 0x90, 0x0b, 0x30, 0xea, 0x1e, 0xc3, 0x49, 0xad, 0xae, 0x30, 0x79, 0x54, 0x80, 0xd2, 0xf8, 0x8f, 0x82, 0xe2, 0x2f, 0x88, 0x07, 0xe0, 0x37, 0x2f, 0x68 }) // cannot reshape array (incompatible input/output shape)
TRANSLATION("Nordic Soft Device failure assertion.", 38, { 0xed, 0x56, 0xa1, 0xcc, 0x3c, 0x17, 0x38, 0x0e, 0xb2, 0xe2, 0x73, 0x20, 0xcc, 0x4e, 0xb8, 0x62, 0x01, 0x77, 0x26, 0x83, 0x54, 0xe7 }) // Nordic Soft Device failure assertion.
TRANSLATION("'%s' object is not an iterator", 31, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x0d, 0xc1, 0x16, 0x00, 0x50, 0x0e, 0x09, 0x86, 0x15, 0x80 }) // \'%s\' object is not an iterator
TRANSLATION("Buffer must be at least length 1", 33, { 0xf9, 0xe3, 0x3c, 0xc9, 0x82, 0xd8, 0x78, 0x0c, 0x88, 0x06, 0x02, 0xa4, 0x2f, 0x01, 0x52, 0x4d, 0x23, 0x80, 0x74, 0x00 }) // Buffer must be at least length 1
TRANSLATION("buffer size must match format", 30, { 0xcb, 0x19, 0xe6, 0x4c, 0x0e, 0x7f, 0xc9, 0x05, 0xb0, 0xf0, 0x16, 0x18, 0x9f, 0x00, 0xcd, 0x5a, 0xc3, 0x00 }) // buffer size must match format
TRANSLATION("generator ignored GeneratorExit", 32, { 0xd0, 0x90, 0x98, 0x61, 0x58, 0x0f, 0x44, 0x56, 0x2a, 0x07, 0xd4, 0x90, 0x98, 0x61, 0x5b, 0x77, 0x23, 0x80 }) // generator ignored GeneratorExit
TRANSLATION("complex division by zero", 25, { 0x9a, 0xda, 0xf5, 0x2e, 0x41, 0x43, 0xe2, 0x6e, 0x6a, 0x81, 0x96, 0xa1, 0xfc, 0x93, 0x28 }) // complex division by zero
TRANSLATION("'%s' object does not support item deletion", 43, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x28, 0xa4, 0xe0, 0x8b, 0x00, 0xf8, 0xbd, 0xd5, 0xa0, 0x0e, 0x0a, 0xc1, 0x42, 0xa9, 0x41, 0xaa, 0x00 }) // \'%s\' object does not support item deletion
TRANSLATION("non-default argument follows default argument", 46, { 0x45, 0x4f, 0x7d, 0x0b, 0x31, 0xc5, 0x60, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x33, 0x5a, 0xd5, 0x7d, 0x1c, 0x28, 0x59, 0x8e, 0x2b, 0x00, 0x2d, 0xa6, 0x2c, 0x49, 0x00 }) // non-default argument follows default argument
TRANSLATION("wrong number of values to unpack", 33, { 0xf4, 0x65, 0x4d, 0x01, 0x31, 0x6c, 0x89, 0x81, 0x73, 0x0e, 0x23, 0x5c, 0x13, 0x84, 0x28, 0x61, 0x2e, 0x33, 0xf2 }) // wrong number of values to unpack
TRANSLATION("input must be tuple, list, range, or ndarray", 45, { 0x34, 0xbe, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x82, 0x31, 0x7a, 0x97, 0xb8, 0x2a, 0x6f, 0x1e, 0xe0, 0x61, 0x4d, 0x0b, 0xdc, 0x0a, 0xc0, 0x94, 0x16, 0x61, 0xd4 }) // input must be tuple, list, range, or ndarray
TRANSLATION("abort() called", 15, { 0x1c, 0x95, 0xa3, 0xd9, 0xed, 0x09, 0x8d, 0x6a, 0x54 }) // abort() called
TRANSLATION("object is not subscriptable", 28, { 0x5c, 0xbf, 0x05, 0x38, 0x03, 0x70, 0x45, 0x80, 0x7c, 0x64, 0xf3, 0x63, 0xbc, 0x0e, 0x55, 0x20 }) // object is not subscriptable
TRANSLATION("'%q' argument required", 23, { 0xd9, 0xcd, 0xe7, 0xb0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x18, 0xbc, 0xf0, 0x6c, 0x54 }) // \'%q\' argument required
TRANSLATION("lhs and rhs should be compatible", 33, { 0xaf, 0x07, 0x01, 0x4a, 0x03, 0x70, 0x70, 0x7e, 0x0b, 0x8a, 0xd0, 0x32, 0x20, 0x9a, 0xda, 0xe3, 0x07, 0x95, 0x48 }) // lhs and rhs should be compatible
TRANSLATION("dict update sequence has wrong length", 38, { 0xa1, 0xce, 0x03, 0x17, 0xa0, 0xc1, 0x03, 0x97, 0x9e, 0x09, 0x26, 0x41, 0xc0, 0x5c, 0x3d, 0x19, 0x53, 0x40, 0xa9, 0x26, 0x91, 0xc0 }) // dict update sequence has wrong length
TRANSLATION("No MISO Pin", 12, { 0xed, 0x50, 0xfb, 0x76, 0x78, 0x77, 0x06, 0xf3, 0x40 }) // No MISO Pin
TRANSLATION("Invalid ADC Unit value", 23, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x74, 0xf5, 0xf5, 0x07, 0xdd, 0x0e, 0x03, 0x88, 0xd7, 0x04 }) // Invalid ADC Unit value
TRANSLATION("tuple/list required on RHS", 27, { 0x8c, 0x5e, 0xa5, 0xf0, 0xa9, 0xbc, 0x03, 0x17, 0x9e, 0x0d, 0x8a, 0x80, 0xa8, 0x1d, 0xff, 0xe7, 0xc0 }) // tuple/list required on RHS
TRANSLATION("type is not an acceptable base type", 36, { 0x8d, 0x6e, 0x40, 0x6e, 0x08, 0xb0, 0x02, 0x80, 0x33, 0x99, 0x5e, 0x07, 0x2a, 0x90, 0x64, 0x2e, 0x41, 0x1a, 0xdc, 0x80 }) // type is not an acceptable base type
TRANSLATION("keyword argument(s) not yet implemented - use normal args instead", 66, { 0xf2, 0x2d, 0x7d, 0x15, 0xa8, 0x02, 0xda, 0x62, 0xc4, 0x91, 0xec, 0x7f, 0x68, 0x22, 0xc0, 0x6a, 0x50, 0x07, 0x6b, 0xd4, 0xac, 0x49, 0x05, 0x40, 0xf7, 0x86, 0x1c, 0x81, 0x15, 0xac, 0x35, 0x01, 0x6d, 0x1c, 0x0d, 0x1e, 0x08, 0x68 }) // keyword argument(s) not yet implemented - use normal args instead
TRANSLATION("function takes %d positional arguments but %d were given", 57, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0x81, 0xf2, 0x27, 0x0e, 0x6a, 0x05, 0xd5, 0xce, 0x0d, 0x50, 0x6a, 0x02, 0xda, 0x62, 0xc4, 0x90, 0xe1, 0x96, 0x20, 0x39, 0xa8, 0x1e, 0x84, 0xc4, 0x1a, 0x1f, 0x12, 0x40 }) // function takes %d positional arguments but %d were given
TRANSLATION("No MOSI Pin", 12, { 0xed, 0x50, 0xfb, 0x77, 0x78, 0x76, 0x06, 0xf3, 0x40 }) // No MOSI Pin
TRANSLATION("Invalid pins for PWMOut", 24, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x5c, 0xd1, 0xc3, 0x35, 0x60, 0xdf, 0xfc, 0x7d, 0xbb, 0xb1, 0x00 }) // Invalid pins for PWMOut
TRANSLATION("matrix is not positive definite", 32, { 0xb0, 0xc3, 0x1f, 0x20, 0x37, 0x04, 0x58, 0x0b, 0xab, 0x9c, 0x1f, 0x12, 0x0a, 0x16, 0x66, 0x87, 0x04 }) // matrix is not positive definite
TRANSLATION("Length must be non-negative", 28, { 0xfd, 0xc9, 0x34, 0x8e, 0x01, 0x6c, 0x3c, 0x06, 0x44, 0x08, 0xa9, 0xef, 0x42, 0xd0, 0x60, 0xf8, 0x90 }) // Length must be non-negative
TRANSLATION("number of points must be at least 2", 36, { 0x4c, 0x5b, 0x22, 0x60, 0x5c, 0xc2, 0xea, 0x69, 0x0e, 0x16, 0xc3, 0xc0, 0x64, 0x40, 0x30, 0x15, 0x21, 0x78, 0x0f, 0x88 }) // number of points must be at least 2
TRANSLATION("operation is not implemented on ndarrays", 41, { 0x5b, 0x93, 0x0c, 0x1a, 0xa0, 0x1b, 0x82, 0x2c, 0x01, 0xda, 0xf5, 0x2b, 0x12, 0x41, 0x50, 0x15, 0x01, 0x28, 0x2c, 0xc3, 0xab, 0x80 }) // operation is not implemented on ndarrays
TRANSLATION("offset out of bounds", 21, { 0x5c, 0xf3, 0x72, 0x80, 0x5c, 0x40, 0x2e, 0x61, 0x92, 0xe1, 0x28, 0xe0 }) // offset out of bounds
TRANSLATION("invalid syntax for integer", 27, { 0x34, 0xe2, 0x35, 0x3a, 0x03, 0xea, 0x90, 0x3c, 0x83, 0x35, 0x60, 0x34, 0x82, 0xd0, 0x98 }) // invalid syntax for integer
TRANSLATION("__init__() should return None", 30, { 0x94, 0x8d, 0x0e, 0x25, 0x2f, 0x67, 0xb4, 0x1f, 0x82, 0xe2, 0xb4, 0x06, 0x28, 0xc3, 0x20, 0x76, 0xaa, 0x10 }) // __init__() should return None
TRANSLATION("issubclass() arg 2 must be a class or a tuple of classes", 57, { 0x37, 0x7c, 0x65, 0x3a, 0x8b, 0xbf, 0xb3, 0xda, 0x02, 0xda, 0x07, 0xc4, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x42, 0x75, 0x17, 0x70, 0x56, 0x01, 0x08, 0xc5, 0xea, 0x40, 0xb9, 0x84, 0xea, 0x2e, 0xe4, 0xe0 }) // issubclass() arg 2 must be a class or a tuple of classes
TRANSLATION("negative shift count", 21, { 0x42, 0xd0, 0x60, 0xf8, 0x90, 0x3f, 0x03, 0xce, 0x02, 0x6b, 0x84, 0x80 }) // negative shift count
TRANSLATION("index is out of bounds", 23, { 0x34, 0xa1, 0x72, 0x03, 0x70, 0x5c, 0x40, 0x2e, 0x61, 0x92, 0xe1, 0x28, 0xe0 }) // index is out of bounds
TRANSLATION("unexpected keyword argument '%q'", 33, { 0xc2, 0x17, 0x2b, 0x94, 0xe0, 0xa8, 0x1e, 0x45, 0xaf, 0xa2, 0xb5, 0x00, 0x5b, 0x4c, 0x58, 0x92, 0x03, 0x67, 0x37, 0x9e, 0xc0 }) // unexpected keyword argument \'%q\'
TRANSLATION("You are in safe mode: something unanticipated happened.\n", 58, { 0xff, 0xb5, 0xc0, 0x0b, 0x10, 0x1a, 0x03, 0x8e, 0x64, 0x16, 0x5a, 0x17, 0xec, 0x0e, 0xb6, 0x28, 0xe0, 0x69, 0xa0, 0x61, 0x05, 0x20, 0xe6, 0x77, 0x18, 0x2a, 0x07, 0x01, 0xbd, 0xc9, 0x0a, 0x9c, 0xfe, 0xbf, 0x50 }) // You are in safe mode: something unanticipated happened.\r\n
TRANSLATION("convolve arguments must be ndarrays", 36, { 0x9a, 0xa7, 0x15, 0xaf, 0x12, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x70, 0xb6, 0x1e, 0x03, 0x22, 0x04, 0xa0, 0xb3, 0x0e, 0xae }) // convolve arguments must be ndarrays
TRANSLATION("can't send non-None value to a just-started generator", 54, { 0x98, 0xa6, 0xc8, 0x07, 0x24, 0xa0, 0x22, 0xa7, 0xbf, 0xb5, 0x50, 0x83, 0x88, 0xd7, 0x04, 0x10, 0xa0, 0x21, 0xf8, 0xc3, 0xc7, 0xbd, 0xe0, 0x5a, 0x0a, 0x81, 0xa1, 0x21, 0x30, 0xc2, 0xb0 }) // can\'t send non-None value to a just-started generator
TRANSLATION("Stack size must be at least 256", 32, { 0xf0, 0x81, 0x9f, 0x90, 0x39, 0xff, 0x24, 0x16, 0xc3, 0xc0, 0x64, 0x40, 0x30, 0x15, 0x21, 0x78, 0x0f, 0x8f, 0xcb, 0xf4 }) // Stack size must be at least 256
TRANSLATION("Could not start PWM", 20, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0xf0, 0x2d, 0x01, 0xbf, 0xf8, 0xfb, 0x00 }) // Could not start PWM
TRANSLATION("sort argument must be an ndarray", 33, { 0x75, 0x68, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x14, 0x04, 0xa0, 0xb3, 0x0e, 0xa0 }) // sort argument must be an ndarray
TRANSLATION("3-arg pow() not supported", 26, { 0xfc, 0xbd, 0xe2, 0xda, 0x05, 0xd7, 0xd3, 0xd9, 0xed, 0x04, 0x58, 0x07, 0xc5, 0xee, 0xad, 0x05, 0x40 }) // 3-arg pow() not supported
TRANSLATION("expecting just a value for set", 31, { 0x2e, 0x57, 0x29, 0xc1, 0xa6, 0x81, 0xf8, 0xc3, 0xc0, 0x08, 0x71, 0x1a, 0xe0, 0x83, 0x35, 0x60, 0x72, 0x80 }) // expecting just a value for set
TRANSLATION("Unsupported operation", 22, { 0xfb, 0xa3, 0xe2, 0xf7, 0x56, 0x82, 0xa0, 0x2d, 0xc9, 0x86, 0x0d, 0x50 }) // Unsupported operation
TRANSLATION("Could not initialize channel", 29, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0x68, 0x70, 0x63, 0x53, 0xfe, 0x48, 0x27, 0xc0, 0x51, 0x0a, 0xa0 }) // Could not initialize channel
TRANSLATION("Cannot vary frequency on a timer that is already in use", 56, { 0xea, 0x14, 0x45, 0x80, 0xe2, 0x2d, 0xa8, 0x66, 0xc5, 0xe7, 0x82, 0x49, 0xea, 0x0a, 0x80, 0x21, 0x07, 0x62, 0x60, 0x8e, 0x03, 0x00, 0x6e, 0x03, 0x56, 0x21, 0xa6, 0xa0, 0x68, 0x18, 0x72 }) // Cannot vary frequency on a timer that is already in use
TRANSLATION("unicode name escapes", 21, { 0xc2, 0x1c, 0xd6, 0x84, 0x08, 0x36, 0x20, 0x27, 0x98, 0xdc, 0x9c }) // unicode name escapes
TRANSLATION("argument num/types mismatch", 28, { 0x16, 0xd3, 0x16, 0x24, 0x80, 0x4c, 0x5b, 0xe1, 0x1a, 0xdc, 0x9c, 0x2c, 0x6f, 0x61, 0x89, 0xf0 }) // argument num/types mismatch
TRANSLATION("timeout must be 0.0-100.0 seconds", 34, { 0x83, 0xb1, 0x2e, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x83, 0x6f, 0x3e, 0xdf, 0x7f, 0x46, 0xdd, 0xbc, 0xfb, 0x41, 0xca, 0x6a, 0x94, 0x70 }) // timeout must be 0.0-100.0 seconds
TRANSLATION("first argument to super() must be type", 39, { 0xcc, 0xd9, 0xe0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x21, 0x41, 0xf1, 0x72, 0x6f, 0x67, 0xb4, 0x2d, 0x87, 0x80, 0xc8, 0x82, 0x35, 0xb9, 0x00 }) // first argument to super() must be type
TRANSLATION("UART write error", 17, { 0xfb, 0xf4, 0xf7, 0xf8, 0x87, 0xa3, 0x1c, 0x10, 0x13, 0x32, 0xb0 }) // UART write error
TRANSLATION("function is implemented for scalars and ndarrays only", 54, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0x37, 0x03, 0xb5, 0xea, 0x56, 0x24, 0x82, 0xa0, 0x66, 0xac, 0x0f, 0x31, 0xa8, 0xb3, 0x80, 0xa5, 0x01, 0x28, 0x2c, 0xc3, 0xab, 0x82, 0xa5, 0x75 }) // function is implemented for scalars and ndarrays only
TRANSLATION("No hardware random available", 29, { 0xed, 0x50, 0xe0, 0x2d, 0x4f, 0x41, 0x62, 0x06, 0x14, 0xa2, 0xd8, 0x07, 0x88, 0x9d, 0x47, 0x2a, 0x90 }) // No hardware random available
TRANSLATION("non-keyword arg after keyword arg", 34, { 0x45, 0x4f, 0x7f, 0x91, 0x6b, 0xe8, 0xad, 0x40, 0x16, 0xd0, 0x07, 0x38, 0x26, 0x0f, 0x22, 0xd7, 0xd1, 0x5a, 0x80, 0x2d, 0xa0 }) // non-keyword arg after keyword arg
TRANSLATION("multiple *x in assignment", 26, { 0xb6, 0x2b, 0x07, 0x7a, 0x90, 0x7f, 0x4e, 0x40, 0x68, 0x02, 0xee, 0x7a, 0x25, 0x89, 0x20 }) // multiple *x in assignment
TRANSLATION("more degrees of freedom than data points", 41, { 0xb2, 0xb1, 0x05, 0x0b, 0x46, 0x22, 0x70, 0x5c, 0xc3, 0x36, 0x22, 0xa2, 0xd8, 0x23, 0x80, 0xa0, 0x50, 0x60, 0x42, 0xea, 0x69, 0x0e }) // more degrees of freedom than data points
TRANSLATION("operands could not be broadcast together", 41, { 0x5b, 0x93, 0x0a, 0x51, 0xc2, 0x6b, 0x8a, 0xd0, 0x11, 0x60, 0x32, 0x20, 0xc9, 0x94, 0x69, 0x31, 0x78, 0x08, 0x5d, 0x0a, 0x38, 0x13, 0x00 }) // operands could not be broadcast together
TRANSLATION("tx and rx cannot both be None", 30, { 0x8e, 0x40, 0x29, 0x40, 0x6e, 0x41, 0x31, 0x44, 0x58, 0x0c, 0x96, 0x38, 0x06, 0x44, 0x1d, 0xaa, 0x84 }) // tx and rx cannot both be None
TRANSLATION("The microcontroller's power dipped. Make sure your power supply provides\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\n", 155, { 0xf1, 0xe0, 0x41, 0x63, 0x9b, 0x2c, 0xd5, 0x21, 0x96, 0xb5, 0x26, 0xd8, 0xe1, 0x75, 0xf4, 0x26, 0x0a, 0x1d, 0xee, 0x54, 0xe7, 0x0f, 0xb0, 0xf9, 0x10, 0x3e, 0x18, 0x83, 0x55, 0xc3, 0x05, 0xd7, 0xd0, 0x98, 0x1f, 0x17, 0xbd, 0x75, 0x0b, 0xb2, 0xf1, 0x3a, 0x13, 0xfa, 0xfd, 0x44, 0x8b, 0x8d, 0x38, 0x05, 0xd7, 0xd0, 0x98, 0x33, 0x56, 0x08, 0xe0, 0x41, 0xe9, 0xc1, 0x6a, 0x41, 0x33, 0x69, 0xe0, 0xe0, 0x05, 0x28, 0x17, 0x62, 0x77, 0x06, 0x27, 0x28, 0x0f, 0x60, 0xe7, 0x04, 0xc0, 0x5f, 0x82, 0x9c, 0x1a, 0x68, 0x1d, 0x5d, 0x9d, 0xfd, 0x5f, 0x7e, 0xcf, 0x1d, 0xff, 0xf7, 0xed, 0xe7, 0xf5, 0xfa, 0x80 }) // The microcontroller\'s power dipped. Make sure your power supply provides\r\nenough power for the whole circuit and press reset (after ejecting CIRCUITPY).\r\n
TRANSLATION("string index out of range", 26, { 0x78, 0x63, 0x4d, 0x00, 0xd2, 0x85, 0xc8, 0x17, 0x10, 0x0b, 0x98, 0x30, 0xa6, 0x84 }) // string index out of range
TRANSLATION("'return' outside function", 26, { 0xd8, 0xc5, 0x18, 0x64, 0xd8, 0x0b, 0x88, 0x73, 0xa1, 0x06, 0x78, 0x49, 0xc1, 0xaa, 0x00 }) // \'return\' outside function
TRANSLATION("requested length %d but object has length %d", 45, { 0x62, 0xf3, 0xc1, 0x3c, 0x15, 0x02, 0xa4, 0x9a, 0x47, 0x00, 0xe6, 0xa0, 0x65, 0x88, 0x05, 0xcb, 0xf0, 0x53, 0x80, 0xe0, 0x2e, 0x15, 0x24, 0xd2, 0x38, 0x07, 0x35, 0x00 }) // requested length %d but object has length %d
TRANSLATION("unknown conversion specifier %c", 32, { 0xc2, 0x79, 0x22, 0xfa, 0x20, 0x4d, 0x53, 0x89, 0x33, 0x9a, 0xa0, 0x3d, 0xca, 0x67, 0x99, 0x93, 0x07, 0x34, 0xc0 }) // unknown conversion specifier %c
TRANSLATION("memory allocation failed, heap is locked", 41, { 0xb1, 0x59, 0x5b, 0x50, 0x1a, 0xd5, 0x66, 0x30, 0x6a, 0x81, 0x98, 0x9d, 0x4a, 0x9e, 0xe0, 0xe0, 0x43, 0x70, 0x37, 0x0a, 0xac, 0xfc, 0x8a, 0x80 }) // memory allocation failed, heap is locked
TRANSLATION("%q index out of range", 22, { 0xe6, 0xf3, 0x03, 0x4a, 0x17, 0x20, 0x5c, 0x40, 0x2e, 0x60, 0xc2, 0x9a, 0x10 }) // %q index out of range
TRANSLATION("Plus any modules on the filesystem\n", 37, { 0xdf, 0x5c, 0x38, 0x0a, 0x6a, 0x16, 0x5a, 0x62, 0xa4, 0xe0, 0xa8, 0x11, 0xc0, 0x83, 0x33, 0xa9, 0x3e, 0xaf, 0x05, 0x6f, 0x5f, 0xa8 }) // Plus any modules on the filesystem\r\n
TRANSLATION("%q indices must be integers, not %s", 36, { 0xe6, 0xf3, 0x03, 0x4a, 0x1c, 0xc9, 0xc2, 0xd8, 0x78, 0x0c, 0x88, 0x0d, 0x20, 0xb4, 0x26, 0x7f, 0x70, 0x22, 0xc0, 0x73, 0x38 }) // %q indices must be integers, not %s
TRANSLATION("UART Init Error", 16, { 0xfb, 0xf4, 0xf7, 0xf8, 0x87, 0x62, 0x1c, 0x06, 0xe6, 0x65, 0x60 }) // UART Init Error
TRANSLATION("Could not re-init timer", 24, { 0xea, 0x5c, 0x56, 0x80, 0x8b, 0x00, 0xc5, 0xef, 0x34, 0x38, 0x08, 0x3b, 0x13, 0x00 }) // Could not re-init timer
TRANSLATION("a bytes-like object is required", 32, { 0x10, 0xcb, 0x58, 0x27, 0xf7, 0xd4, 0xfc, 0x88, 0x17, 0x2f, 0xc1, 0x4e, 0x00, 0xdc, 0x18, 0xbc, 0xf0, 0x6c, 0x54 }) // a bytes-like object is required
TRANSLATION("object does not support item deletion", 38, { 0x5c, 0xbf, 0x05, 0x38, 0x0a, 0x29, 0x38, 0x22, 0xc0, 0x3e, 0x2f, 0x75, 0x68, 0x03, 0x82, 0xb0, 0x50, 0xaa, 0x50, 0x6a, 0x80 }) // object does not support item deletion
TRANSLATION("small int overflow", 19, { 0x7b, 0x0d, 0x6a, 0x06, 0x90, 0x0b, 0xc4, 0x9b, 0x3a, 0xaf, 0xa0 }) // small int overflow
TRANSLATION("flip argument must be an ndarray", 33, { 0xce, 0xa7, 0x70, 0x16, 0xd3, 0x16, 0x24, 0x80, 0xb6, 0x1e, 0x03, 0x22, 0x01, 0x40, 0x4a, 0x0b, 0x30, 0xea }) // flip argument must be an ndarray
TRANSLATION("constant must be an integer", 28, { 0x9a, 0xa3, 0xc0, 0xa4, 0x05, 0xb0, 0xf0, 0x19, 0x10, 0x0a, 0x01, 0xa4, 0x16, 0x84, 0xc0 }) // constant must be an integer
TRANSLATION("input matrix is asymmetric", 27, { 0x34, 0xbe, 0x20, 0x2c, 0x30, 0xc7, 0xc8, 0x0d, 0xc0, 0x5f, 0x5b, 0x58, 0xa1, 0x8e, 0x60 }) // input matrix is asymmetric
TRANSLATION("odd-length string", 18, { 0x5a, 0x53, 0xdf, 0x52, 0x4d, 0x23, 0x80, 0x3c, 0x31, 0xa6, 0x80 }) // odd-length string
TRANSLATION("unsupported type for %q: '%s'", 30, { 0xc2, 0x3e, 0x2f, 0x75, 0x68, 0x2a, 0x04, 0x6b, 0x72, 0x0c, 0xd5, 0x83, 0x9b, 0xcf, 0xf6, 0x0d, 0x9c, 0xcf, 0xb0 }) // unsupported type for %q: \'%s\'
TRANSLATION("'%s' object does not support '%q'", 34, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x28, 0xa4, 0xe0, 0x8b, 0x00, 0xf8, 0xbd, 0xd5, 0xa0, 0x36, 0x73, 0x79, 0xec }) // \'%s\' object does not support \'%q\'
TRANSLATION("__init__() should return None, not '%s'", 40, { 0x94, 0x8d, 0x0e, 0x25, 0x2f, 0x67, 0xb4, 0x1f, 0x82, 0xe2, 0xb4, 0x06, 0x28, 0xc3, 0x20, 0x76, 0xaa, 0x17, 0xb8, 0x11, 0x60, 0x36, 0x73, 0x3e, 0xc0 }) // __init__() should return None, not \'%s\'
TRANSLATION("Drive mode not used when direction is input.", 45, { 0xeb, 0x63, 0xe2, 0x41, 0x65, 0xa1, 0x02, 0x2c, 0x06, 0x1c, 0xa8, 0x1e, 0x9c, 0x09, 0x02, 0x86, 0xc5, 0x38, 0x35, 0x40, 0x37, 0x03, 0x4b, 0xe2, 0x39, 0xc0 }) // Drive mode not used when direction is input.
TRANSLATION("Expected a %q", 14, { 0xdd, 0xca, 0xe5, 0x38, 0x2a, 0x00, 0x87, 0x37, 0x98 }) // Expected a %q
TRANSLATION("Supply at least one UART pin", 29, { 0xf0, 0xc5, 0xef, 0x5d, 0x40, 0x60, 0x2a, 0x42, 0xf0, 0x0a, 0x84, 0x1f, 0x7e, 0x9e, 0xff, 0x10, 0xb9, 0xa0 }) // Supply at least one UART pin
TRANSLATION("input array length must be power of 2", 38, { 0x34, 0xbe, 0x20, 0x05, 0x98, 0x75, 0x0a, 0x92, 0x69, 0x1c, 0x02, 0xd8, 0x78, 0x0c, 0x88, 0x2e, 0xbe, 0x84, 0xc0, 0xb9, 0x87, 0xc4 }) // input array length must be power of 2
TRANSLATION("Invalid frequency supplied", 27, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x66, 0xc5, 0xe7, 0x82, 0x49, 0xea, 0x0f, 0x8b, 0xde, 0xa6, 0x54 }) // Invalid frequency supplied
TRANSLATION("Running in safe mode! Auto-reload is off.\n", 44, { 0xef, 0xc2, 0x21, 0xa6, 0x80, 0x68, 0x0e, 0x39, 0x90, 0x59, 0x68, 0x5f, 0xf0, 0x1d, 0x38, 0x85, 0xf7, 0xb1, 0x55, 0x46, 0x80, 0x6e, 0x0b, 0x9e, 0x7c, 0xfe, 0xbf, 0x50 }) // Running in safe mode! Auto-reload is off.\r\n
TRANSLATION("No pulldown on pin; 1Mohm recommended", 38, { 0xed, 0x50, 0xbe, 0x2b, 0x5a, 0x2f, 0xa2, 0x02, 0xa0, 0x5c, 0xd3, 0xff, 0x61, 0xd1, 0xf6, 0x5e, 0x16, 0x06, 0x29, 0xad, 0xac, 0x49, 0x42, 0xa0 }) // No pulldown on pin; 1Mohm recommended
TRANSLATION("can't switch from automatic field numbering to manual field specification", 74, { 0x98, 0xa6, 0xc8, 0x07, 0xf4, 0x38, 0x9f, 0x00, 0xcd, 0x96, 0xc0, 0x38, 0x85, 0xb0, 0xc1, 0xcc, 0x33, 0x32, 0xad, 0x01, 0x31, 0x6c, 0x89, 0x8d, 0x34, 0x08, 0x50, 0xb0, 0xa6, 0x06, 0xa1, 0x99, 0x95, 0x68, 0x0f, 0x72, 0x99, 0xe6, 0x73, 0x18, 0x35, 0x40 }) // can\'t switch from automatic field numbering to manual field specification
TRANSLATION("__new__ arg must be a user-type", 32, { 0x94, 0x90, 0xbd, 0x25, 0x20, 0x16, 0xd0, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x43, 0x0e, 0x4d, 0xef, 0x8d, 0x6e, 0x40 }) // __new__ arg must be a user-type
TRANSLATION("'%s' object does not support item assignment", 45, { 0xd9, 0xcc, 0xfb, 0x01, 0x72, 0xfc, 0x14, 0xe0, 0x28, 0xa4, 0xe0, 0x8b, 0x00, 0xf8, 0xbd, 0xd5, 0xa0, 0x0e, 0x0a, 0xc0, 0x2e, 0xe7, 0xa2, 0x58, 0x92, 0x00 }) // \'%s\' object does not support item assignment
TRANSLATION("buffer too small", 17, { 0xcb, 0x19, 0xe6, 0x4c, 0x10, 0xaa, 0x0f, 0x61, 0xad, 0x40 }) // buffer too small
TRANSLATION("Unable to init parser", 22, { 0xfb, 0xa0, 0xe5, 0x52, 0x08, 0x50, 0x34, 0x38, 0x0b, 0x8b, 0x39, 0x30 }) // Unable to init parser
TRANSLATION("stop not reachable from start", 30, { 0x78, 0x5b, 0x82, 0x2c, 0x03, 0x10, 0xcf, 0x80, 0xe5, 0x52, 0x0c, 0xd9, 0x6c, 0x0f, 0x02, 0xd0 }) // stop not reachable from start
TRANSLATION("Splitting with sub-captures", 28, { 0xf0, 0xbd, 0x4e, 0x20, 0xd3, 0x40, 0xf4, 0x38, 0xe0, 0x0f, 0x8c, 0xbd, 0xf3, 0x1b, 0xc6, 0x18, 0x9c }) // Splitting with sub-captures
TRANSLATION("string not supported; use bytes or bytearray", 45, { 0x78, 0x63, 0x4d, 0x01, 0x16, 0x01, 0xf1, 0x7b, 0xab, 0x41, 0x53, 0xff, 0x61, 0x87, 0x20, 0xcb, 0x58, 0x27, 0x05, 0x60, 0xcb, 0x58, 0x21, 0x66, 0x1d, 0x40 }) // string not supported; use bytes or bytearray
TRANSLATION("cannot perform relative import", 31, { 0x98, 0xa2, 0x2c, 0x05, 0xc9, 0xb3, 0x56, 0xb0, 0x31, 0x54, 0x60, 0xf8, 0x90, 0x1d, 0xae, 0xad, 0x00 }) // cannot perform relative import
TRANSLATION("no binding for nonlocal found", 30, { 0x45, 0x0c, 0x8d, 0x28, 0x69, 0xa0, 0x66, 0xac, 0x08, 0xa9, 0x55, 0x98, 0xd4, 0x33, 0x5c, 0x25, 0x00 }) // no binding for nonlocal found
TRANSLATION("object of type '%s' has no len()", 33, { 0x5c, 0xbf, 0x05, 0x38, 0x05, 0xcc, 0x23, 0x5b, 0x90, 0x6c, 0xe6, 0x7d, 0x81, 0xc0, 0x5c, 0x11, 0x42, 0xa4, 0x9e, 0xcf, 0x68 }) // object of type \'%s\' has no len()
TRANSLATION(" output:\n", 11, { 0x05, 0xc4, 0x5f, 0x11, 0xfb, 0x7a, 0xfd, 0x40 }) //  output:\r\n
TRANSLATION("argument has wrong type", 24, { 0x16, 0xd3, 0x16, 0x24, 0x80, 0xe0, 0x2e, 0x1e, 0x8c, 0xa9, 0xa0, 0x46, 0xb7, 0x20 }) // argument has wrong type
TRANSLATION("tuple/list has wrong length", 28, { 0x8c, 0x5e, 0xa5, 0xf0, 0xa9, 0xbc, 0x07, 0x01, 0x70, 0xf4, 0x65, 0x4d, 0x02, 0xa4, 0x9a, 0x47, 0x00 }) // tuple/list has wrong length
TRANSLATION("non-keyword arg after */**", 27, { 0x45, 0x4f, 0x7f, 0x91, 0x6b, 0xe8, 0xad, 0x40, 0x16, 0xd0, 0x07, 0x38, 0x26, 0x0f, 0xe9, 0xf0, 0xfe, 0x9f, 0xd0 }) // non-keyword arg after */**
TRANSLATION("too many values to unpack (expected %d)", 40, { 0x85, 0x50, 0xb0, 0xa6, 0xa1, 0xc4, 0x6b, 0x82, 0x70, 0x85, 0x0c, 0x25, 0xc6, 0x7e, 0x41, 0xec, 0x2e, 0x57, 0x29, 0xc1, 0x50, 0x39, 0xa9, 0xed }) // too many values to unpack (expected %d)
TRANSLATION("function missing keyword-only argument", 39, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0xb1, 0xbb, 0x9a, 0x68, 0x1e, 0x45, 0xaf, 0xa2, 0xb5, 0x3d, 0xea, 0x95, 0xd4, 0x05, 0xb4, 0xc5, 0x89, 0x20 }) // function missing keyword-only argument
TRANSLATION("could not invert Vandermonde matrix", 36, { 0x9a, 0xe2, 0xb4, 0x04, 0x58, 0x03, 0x4e, 0x24, 0xd0, 0x1f, 0xe8, 0x52, 0x84, 0xd6, 0x54, 0xa1, 0x05, 0x86, 0x18, 0xf9, 0x00 }) // could not invert Vandermonde matrix
TRANSLATION("MicroPython NLR jump failed. Likely memory corruption.", 55, { 0xfb, 0x1c, 0xd9, 0x77, 0xeb, 0x1c, 0x15, 0x03, 0xb7, 0xf7, 0xef, 0x0f, 0xc6, 0x2d, 0x70, 0xcc, 0x4e, 0xa5, 0x4e, 0x70, 0xfd, 0xcf, 0xc8, 0xab, 0xa8, 0x58, 0xac, 0xad, 0xa8, 0x4d, 0x59, 0xb1, 0x78, 0x35, 0x4e, 0x70 }) // MicroPython NLR jump failed. Likely memory corruption.
TRANSLATION("time.struct_time() takes a 9-sequence", 38, { 0x83, 0xb1, 0x73, 0xbc, 0x36, 0x27, 0x12, 0x83, 0xb1, 0x7b, 0x3d, 0xa1, 0x03, 0xe4, 0x4e, 0x02, 0x1f, 0xdb, 0xde, 0xe5, 0xe7, 0x82, 0x49, 0x90 }) // time.struct_time() takes a 9-sequence
TRANSLATION("need more than %d values to unpack", 35, { 0x42, 0x2a, 0x05, 0x95, 0x88, 0x23, 0x80, 0xa0, 0x73, 0x50, 0x38, 0x8d, 0x70, 0x4e, 0x10, 0xa1, 0x84, 0xb8, 0xcf, 0xc8 }) // need more than %d values to unpack
TRANSLATION("default 'except' must be last", 30, { 0xa1, 0x66, 0x38, 0xac, 0x06, 0xc2, 0xe5, 0x32, 0xbc, 0x6c, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0xa8, 0xbc, 0x00 }) // default \'except\' must be last
TRANSLATION("incomplete format", 18, { 0x34, 0x9a, 0xda, 0xf5, 0x28, 0x20, 0xcd, 0x5a, 0xc3, 0x00 }) // incomplete format
TRANSLATION("first argument must be an ndarray", 34, { 0xcc, 0xd9, 0xe0, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x2d, 0x87, 0x80, 0xc8, 0x80, 0x50, 0x12, 0x82, 0xcc, 0x3a, 0x80 }) // first argument must be an ndarray
TRANSLATION("bytes value out of range", 25, { 0xcb, 0x58, 0x27, 0x0e, 0x23, 0x5c, 0x10, 0x2e, 0x20, 0x17, 0x30, 0x61, 0x4d, 0x08 }) // bytes value out of range
TRANSLATION("unknown format code '%c' for object of type '%s'", 49, { 0xc2, 0x79, 0x22, 0xfa, 0x20, 0x66, 0xad, 0x61, 0x80, 0x9a, 0xd0, 0x83, 0x67, 0x34, 0xf6, 0x06, 0x6a, 0xc0, 0xb9, 0x7e, 0x0a, 0x70, 0x0b, 0x98, 0x46, 0xb7, 0x20, 0xd9, 0xcc, 0xfb, 0x00 }) // unknown format code \'%c\' for object of type \'%s\'
TRANSLATION("tuple index out of range", 25, { 0x8c, 0x5e, 0xa4, 0x06, 0x94, 0x2e, 0x40, 0xb8, 0x80, 0x5c, 0xc1, 0x85, 0x34, 0x20 }) // tuple index out of range
TRANSLATION("filesystem must provide mount method", 37, { 0xcc, 0xea, 0x4f, 0xab, 0xc1, 0x58, 0x2d, 0x87, 0x80, 0xbb, 0x2f, 0x13, 0xa1, 0x05, 0x97, 0x09, 0x01, 0x62, 0x8e, 0x0b, 0x40 }) // filesystem must provide mount method
TRANSLATION("Length must be an int", 22, { 0xfd, 0xc9, 0x34, 0x8e, 0x01, 0x6c, 0x3c, 0x06, 0x44, 0x02, 0x80, 0x69, 0x00 }) // Length must be an int
TRANSLATION("invalid syntax", 15, { 0x34, 0xe2, 0x35, 0x3a, 0x03, 0xea, 0x90, 0x3c, 0x80 }) // invalid syntax
TRANSLATION("operation is not supported for given type", 42, { 0x5b, 0x93, 0x0c, 0x1a, 0xa0, 0x1b, 0x82, 0x2c, 0x03, 0xe2, 0xf7, 0x56, 0x82, 0xa0, 0x66, 0xac, 0x1a, 0x1f, 0x12, 0x40, 0x8d, 0x6e, 0x40 }) // operation is not supported for given type
TRANSLATION("0.0 to a complex power", 23, { 0xdb, 0xcf, 0xb4, 0x21, 0x40, 0x42, 0x6b, 0x6b, 0xd4, 0xb9, 0x05, 0xd7, 0xd0, 0x98 }) // 0.0 to a complex power
TRANSLATION("stop must be 1 or 2", 20, { 0x78, 0x5b, 0x85, 0xb0, 0xf0, 0x19, 0x10, 0x74, 0x02, 0xb0, 0x7c, 0x40 }) // stop must be 1 or 2
TRANSLATION("File exists", 12, { 0xfa, 0x1d, 0x48, 0x0b, 0x91, 0xbc, 0x38 }) // File exists
TRANSLATION("convolve arguments must not be empty", 37, { 0x9a, 0xa7, 0x15, 0xaf, 0x12, 0x01, 0x6d, 0x31, 0x62, 0x48, 0x70, 0xb6, 0x1e, 0x01, 0x16, 0x03, 0x22, 0x02, 0xb5, 0xe3, 0x50 }) // convolve arguments must not be empty
TRANSLATION("index out of range", 19, { 0x34, 0xa1, 0x72, 0x05, 0xc4, 0x02, 0xe6, 0x0c, 0x29, 0xa1, 0x00 }) // index out of range
TRANSLATION("can't add special method to already-subclassed class", 53, { 0x98, 0xa6, 0xc8, 0x01, 0xa5, 0x01, 0xee, 0x53, 0x31, 0xa8, 0x58, 0xa3, 0x82, 0xd0, 0x21, 0x40, 0x6a, 0xc4, 0x34, 0xd7, 0xde, 0xf8, 0xca, 0x75, 0x17, 0x72, 0xa0, 0x4e, 0xa2, 0xee }) // can\'t add special method to already-subclassed class
TRANSLATION("could not broadast input array from shape", 42, { 0x9a, 0xe2, 0xb4, 0x04, 0x58, 0x0c, 0x99, 0x46, 0x82, 0xf0, 0x06, 0x97, 0xc4, 0x00, 0xb3, 0x0e, 0xa1, 0x9b, 0x2d, 0x81, 0xf8, 0x0d, 0xc8 }) // could not broadast input array from shape
TRANSLATION("math domain error", 18, { 0xb0, 0xc7, 0x00, 0xa2, 0xd8, 0x4d, 0x00, 0x99, 0x95, 0x80 }) // math domain error
TRANSLATION("Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\n", 86, { 0xe9, 0xc4, 0x2f, 0xbd, 0x8a, 0xaa, 0x34, 0x03, 0x70, 0x54, 0xe7, 0x0f, 0x03, 0xb5, 0xeb, 0xa8, 0x38, 0xf1, 0x20, 0xcc, 0xea, 0x4e, 0x0b, 0xc4, 0x98, 0x3e, 0xfe, 0x1f, 0x30, 0x85, 0x06, 0xc2, 0x04, 0x70, 0x2b, 0x02, 0xb0, 0x12, 0x41, 0x30, 0x77, 0xee, 0xdf, 0xfb, 0x84, 0x28, 0x50, 0xdc, 0x72, 0xa9, 0x73, 0xfa, 0xfd, 0x40 }) // Auto-reload is on. Simply save files over USB to run them or enter REPL to disable.\r\n
TRANSLATION("CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\n", 113, { 0xea, 0x36, 0x9e, 0x0e, 0x37, 0xeb, 0x1c, 0x15, 0x00, 0xdc, 0x0d, 0x01, 0xc7, 0x32, 0x0b, 0x2d, 0x08, 0x32, 0x29, 0x8e, 0x1c, 0x83, 0x55, 0xc0, 0x5d, 0x89, 0xdc, 0xa8, 0x11, 0xc0, 0x81, 0x89, 0xca, 0x03, 0x2c, 0x44, 0x2a, 0x05, 0x30, 0xc6, 0x9a, 0x06, 0x4a, 0xb1, 0xce, 0x1b, 0xd8, 0x9d, 0xc0, 0x74, 0x13, 0x40, 0x85, 0x02, 0xe4, 0x70, 0x0e, 0x39, 0x90, 0x59, 0x68, 0x5c, 0xfe, 0xbf, 0x50 }) // CircuitPython is in safe mode because you pressed the reset button during boot. Press again to exit safe mode.\r\n
TRANSLATION("real and imaginary parts must be of equal length", 49, { 0x62, 0x1a, 0x80, 0xa5, 0x00, 0xec, 0x3a, 0x1a, 0x0b, 0x6a, 0x17, 0x16, 0x87, 0x0b, 0x61, 0xe0, 0x32, 0x20, 0x5c, 0xc0, 0xbc, 0xf0, 0x35, 0x0a, 0x92, 0x69, 0x1c, 0x00 }) // real and imaginary parts must be of equal length
TRANSLATION("*x must be assignment target", 29, { 0xfe, 0x9c, 0x82, 0xd8, 0x78, 0x0c, 0x88, 0x05, 0xdc, 0xf4, 0x4b, 0x12, 0x40, 0x40, 0xb6, 0x85, 0x00 }) // *x must be assignment target
TRANSLATION("input matrix is singular", 25, { 0x34, 0xbe, 0x20, 0x2c, 0x30, 0xc7, 0xc8, 0x0d, 0xc1, 0xcd, 0x34, 0xc5, 0x45, 0x80 }) // input matrix is singular
TRANSLATION("Buffer incorrect size. Should be %d bytes.", 43, { 0xf9, 0xe3, 0x3c, 0xc9, 0x80, 0xd2, 0x6a, 0xcc, 0x53, 0x80, 0x73, 0xfe, 0x4b, 0x9c, 0x3c, 0x38, 0x2e, 0x2b, 0x40, 0xc8, 0x83, 0x9a, 0x81, 0x96, 0xb0, 0x4f, 0xce }) // Buffer incorrect size. Should be %d bytes.
TRANSLATION("can't convert NaN to int", 25, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0xed, 0x1e, 0xd0, 0x85, 0x03, 0x48 }) // can\'t convert NaN to int
TRANSLATION("function takes exactly 9 arguments", 35, { 0xcf, 0x09, 0x38, 0x35, 0x40, 0x81, 0xf2, 0x27, 0x02, 0xe4, 0x33, 0x8a, 0xea, 0x1f, 0xd8, 0x05, 0xb4, 0xc5, 0x89, 0x21, 0xc0 }) // function takes exactly 9 arguments
TRANSLATION("division by zero", 17, { 0xa1, 0xf1, 0x37, 0x35, 0x40, 0xcb, 0x50, 0xfe, 0x49, 0x94 }) // division by zero
TRANSLATION("\nCode done running. Waiting for reload.\n", 43, { 0xf5, 0xfa, 0xba, 0x96, 0x84, 0x14, 0x54, 0x20, 0x6c, 0x22, 0x1a, 0x69, 0xce, 0x1f, 0xc0, 0x9c, 0x1a, 0x68, 0x19, 0xab, 0x03, 0x15, 0x54, 0x69, 0xcf, 0xeb, 0xf5, 0x00 }) // \r\nCode done running. Waiting for reload.\r\n
TRANSLATION("arg is an empty sequence", 25, { 0x16, 0xd0, 0x0d, 0xc0, 0x50, 0x0a, 0xd7, 0x8d, 0x41, 0xcb, 0xcf, 0x04, 0x93, 0x20 }) // arg is an empty sequence
TRANSLATION("can't convert to str implicitly", 32, { 0x98, 0xa6, 0xc8, 0x09, 0xaa, 0x71, 0x26, 0x80, 0x85, 0x07, 0x86, 0x03, 0xb5, 0xea, 0x73, 0x38, 0xae, 0xa0 }) // can\'t convert to str implicitly
TRANSLATION("Cannot delete values", 21, { 0xea, 0x14, 0x45, 0x80, 0xa1, 0x54, 0xa0, 0x83, 0x88, 0xd7, 0x04, 0xe0 }) // Cannot delete values
TRANSLATION("bad conversion specifier", 25, { 0xc8, 0x68, 0x13, 0x54, 0xe2, 0x4c, 0xe6, 0xa8, 0x0f, 0x72, 0x99, 0xe6, 0x64, 0xc0 }) // bad conversion specifier
TRANSLATION("no such attribute", 18, { 0x45, 0x07, 0xc4, 0xf8, 0x00, 0xc4, 0x31, 0xe5, 0x88, 0x20 }) // no such attribute
TRANSLATION("sign not allowed with integer format specifier 'c'", 51, { 0x73, 0xd1, 0x01, 0x16, 0x00, 0x6b, 0x55, 0xf4, 0x2a, 0x07, 0xa1, 0xc7, 0x00, 0x34, 0x82, 0xd0, 0x98, 0x33, 0x56, 0xb0, 0xc0, 0x3d, 0xca, 0x67, 0x99, 0x93, 0x06, 0xc9, 0xec }) // sign not allowed with integer format specifier \'c\'
TRANSLATION("wrong argument type", 20, { 0xf4, 0x65, 0x4d, 0x00, 0x5b, 0x4c, 0x58, 0x92, 0x02, 0x35, 0xb9, 0x00 }) // wrong argument type
TRANSLATION("FFT is defined for ndarrays only", 33, { 0xfa, 0x7d, 0x3c, 0x40, 0xdc, 0x28, 0x59, 0x9a, 0x15, 0x03, 0x35, 0x60, 0x4a, 0x0b, 0x30, 0xea, 0xe0, 0xa9, 0x5d, 0x40 }) // FFT is defined for ndarrays only
TRANSLATION("ord expects a character", 24, { 0x56, 0xa0, 0x17, 0x2b, 0x94, 0xe1, 0xc0, 0x42, 0x7c, 0x05, 0x86, 0x70, 0x4c }) // ord expects a character
TRANSLATION("diff argument must be an ndarray", 33, { 0xa1, 0xe7, 0x98, 0x0b, 0x69, 0x8b, 0x12, 0x40, 0x5b, 0x0f, 0x01, 0x91, 0x00, 0xa0, 0x25, 0x05, 0x98, 0x75 }) // diff argument must be an ndarray
TRANSLATION("too many indices", 17, { 0x85, 0x50, 0xb0, 0xa6, 0xa0, 0x69, 0x43, 0x99, 0x38 }) // too many indices
TRANSLATION("UART De-init error", 19, { 0xfb, 0xf4, 0xf7, 0xf8, 0x87, 0x59, 0x7b, 0xcd, 0x0e, 0x00, 0x99, 0x95, 0x80 }) // UART De-init error
TRANSLATION("Traceback (most recent call last):\n", 37, { 0xf1, 0x61, 0x99, 0x64, 0x33, 0xf2, 0x0f, 0x65, 0x95, 0xe0, 0x18, 0xa6, 0x49, 0x01, 0x31, 0xad, 0x42, 0xa2, 0xf1, 0xed, 0xfd, 0xbd, 0x7e, 0xa0 }) // Traceback (most recent call last):\r\n
TRANSLATION("can't set attribute", 20, { 0x98, 0xa6, 0xc8, 0x07, 0x28, 0x01, 0x88, 0x63, 0xcb, 0x10, 0x40 }) // can\'t set attribute
TRANSLATION("buffer slices must be of equal length", 38, { 0xcb, 0x19, 0xe6, 0x4c, 0x0f, 0x53, 0x99, 0x38, 0x5b, 0x0f, 0x01, 0x91, 0x02, 0xe6, 0x05, 0xe7, 0x81, 0xa8, 0x54, 0x93, 0x48, 0xe0 }) // buffer slices must be of equal length
TRANSLATION("Invalid polarity", 17, { 0xec, 0x4e, 0x23, 0x53, 0xa0, 0x5d, 0x6a, 0x2c, 0x71, 0xa8 }) // Invalid polarity
TRANSLATION("must use keyword argument for key function", 43, { 0xb6, 0x1e, 0x03, 0x0e, 0x41, 0xe4, 0x5a, 0xfa, 0x2b, 0x50, 0x05, 0xb4, 0xc5, 0x89, 0x20, 0x33, 0x56, 0x0f, 0x22, 0xd4, 0x33, 0xc2, 0x4e, 0x0d, 0x50 }) // must use keyword argument for key function
TRANSLATION("Auto-reload is off.\n", 22, { 0xe9, 0xc4, 0x2f, 0xbd, 0x8a, 0xaa, 0x34, 0x03, 0x70, 0x5c, 0xf3, 0xe7, 0xf5, 0xfa, 0x80 }) // Auto-reload is off.\r\n
TRANSLATION("can't pend throw to just-started generator", 43, { 0x98, 0xa6, 0xc8, 0x0b, 0x92, 0x50, 0x23, 0x83, 0x2f, 0xa0, 0x42, 0x87, 0xe3, 0x0f, 0x1e, 0xf7, 0x81, 0x68, 0x2a, 0x06, 0x84, 0x84, 0xc3, 0x0a, 0xc0 }) // can\'t pend throw to just-started generator

// 5730 bytes worth of qstr
// 12818 bytes worth of translations
// 7856 bytes worth of translations compressed
// 4962 bytes saved
